<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5x5x5 Grid of Cubes with Spheres</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.30/Tone.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>

</head>
<body>

    <script>

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        const cubeSize = 10;
        const cubeDistance = 60;

        function createSphere(x, y, z, radius, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            scene.add(sphere);
            return sphere;
        }

        function createCubeWithSphere(x, y, z, opacity) {
            // const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });
            // const cube = new THREE.Mesh(geometry, material);
            const edgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize));
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });
            const cube = new THREE.LineSegments(edgesGeometry, lineMaterial);

            cube.position.set(x, y, z);
            scene.add(cube);

            // Store a random frequency for each cube
            cube.userData.frequency = 440 * Math.pow(2, (Math.floor(Math.random() * 12) - 9) / 12);

             const uniqueObject = createUniqueObject(x, y, z, ['sphere', 'torus', 'tetrahedron'][Math.floor(Math.random() * 3)]);

            return { cube, uniqueObject };
        }


        function createUniqueObject(x, y, z, type) {
                    let geometry;
                    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });

                    switch (type) {
                        case 'sphere':
                            geometry = new THREE.SphereGeometry(cubeSize / 2, 32, 32);
                            break;
                        case 'torus':
                            geometry = new THREE.TorusGeometry(cubeSize / 4, cubeSize / 8, 16, 100);
                            break;
                        case 'tetrahedron':
                            geometry = new THREE.TetrahedronGeometry(cubeSize / 2);
                            break;
                    }

                    const object = new THREE.Mesh(geometry, material);
                    object.position.set(x, y, z);
                    scene.add(object);
                    return object;
        }


        function createGridOfCubesWithSpheres(size) {
            const grid = [];
            const offset = Math.floor(size / 2) * cubeDistance;
            for (let x = -offset; x <= offset; x += cubeDistance) {
                for (let y = -offset; y <= offset; y += cubeDistance) {
                    for (let z = -offset; z <= offset; z += cubeDistance) {
                        const opacity = (x === 0 && y === 0 && z === 0) ? 0.5 : 1;
                        const cubeWithSphere = createCubeWithSphere(x, y, z, opacity);
                        grid.push(cubeWithSphere);
                    }
                }
            }
            return grid;
        }

        const gridOfCubesWithSpheres = createGridOfCubesWithSpheres(9);

        camera.position.z = 300;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let clickedObject = null;

        function animate() {
            requestAnimationFrame(animate);

            gridOfCubesWithSpheres.forEach(obj => {
                obj.cube.rotation.x += 0.01;
                obj.cube.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
        }

            async function onDocumentMouseDown(event) {
                event.preventDefault();

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    clickedObject = intersects[0].object;

                    if (clickedObject.geometry.type === "BoxGeometry") {
                                const targetPosition = clickedObject.position.clone().add(new THREE.Vector3(0, 0, cubeSize * 2.5));

                                // Animate camera position using Tween.js
                                const tween = new TWEEN.Tween(camera.position)
                                    .to(targetPosition, 1000)
                                    .easing(TWEEN.Easing.Quadratic.InOut)
                                    .onUpdate(() => {
                                        controls.update();
                                    })
                                    .start();

                                controls.target.copy(clickedObject.position);

                                // Play sound with the frequency stored in the clicked cube
                                const synth = new Tone.Synth().toDestination();
                                await Tone.start();
                                synth.triggerAttackRelease(clickedObject.userData.frequency, "8n");
                    }
                }
            }
        function animate() {
            requestAnimationFrame(animate);

            // ...

            TWEEN.update();

            renderer.render(scene, camera);
        }


        animate();
        window.addEventListener('mousedown', onDocumentMouseDown, false);

    </script>
</body>
</html>
