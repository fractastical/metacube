<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5x5x5 Grid of Cubes with Spheres</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.30/Tone.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>

</head>
<body>

    <script>

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        const cubeSize = 10;
        const cubeDistance = 60;

        function createSphere(x, y, z, radius, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            scene.add(sphere);
            return sphere;
        }

        function createCubeWithSphere(x, y, z, opacity, geometryType) {
            // const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });
            // const cube = new THREE.Mesh(geometry, material);
            const edgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize));
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });
            const cube = new THREE.LineSegments(edgesGeometry, lineMaterial);

            cube.position.set(x, y, z);
            scene.add(cube);


            // Store a random frequency for each cube
            cube.userData.frequency = 440 * Math.pow(2, (Math.floor(Math.random() * 12) - 9) / 12);

            const uniqueObject = createUniqueObject(x, y, z, geometryType);

                // Create an invisible mesh for click detection
            const invisibleMeshGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const invisibleMeshMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const invisibleMesh = new THREE.Mesh(invisibleMeshGeometry, invisibleMeshMaterial);
            invisibleMesh.position.set(x, y, z);
            scene.add(invisibleMesh);

            invisibleMesh.userData.parentCube = cube;

            return { cube, uniqueObject, invisibleMesh };
        }


function createUniqueObject(x, y, z, type) {
    let geometry;

    // Calculate the distance between the geometry and the center of the grid
    const center = new THREE.Vector3(0, 0, 0);
    const currentPosition = new THREE.Vector3(x, y, z);
    const distanceToCenter = currentPosition.distanceTo(center);

    // Calculate the maximum possible distance
    const gridSize = 9;
    const cubeDistance = cubeSize + 60;
    const maxDistance = Math.sqrt(Math.pow((gridSize * cubeDistance) / 2, 2) * 3);

    // Generate a shade of purple based on the distance to the center
    const lightness = Math.floor((distanceToCenter / maxDistance) * 100);
    const purpleColor = new THREE.Color(`hsl(270, 100%, ${lightness}%)`);

    const material = new THREE.MeshBasicMaterial({ color: purpleColor });

    switch (type) {
        case 'sphere':
            geometry = new THREE.SphereGeometry(cubeSize / 2, 32, 32);
            break;
        case 'torus':
            geometry = new THREE.TorusGeometry(cubeSize / 4, cubeSize / 8, 16, 100);
            break;
        case 'tetrahedron':
            geometry = new THREE.TetrahedronGeometry(cubeSize / 2);
            break;
        case 'cone':
            geometry = new THREE.ConeGeometry(cubeSize / 2, cubeSize, 32);
            break;
        case 'cylinder':
            geometry = new THREE.CylinderGeometry(cubeSize / 2, cubeSize / 2, cubeSize, 32);
            break;
        case 'icosahedron':
            geometry = new THREE.IcosahedronGeometry(cubeSize / 2);
            break;
        case 'octahedron':
            geometry = new THREE.OctahedronGeometry(cubeSize / 2);
            break;
        case 'torusKnot':
            geometry = new THREE.TorusKnotGeometry(cubeSize / 4, cubeSize / 8, 100, 16);
            break;
        case 'dodecahedron':
            geometry = new THREE.DodecahedronGeometry(cubeSize / 2);
            break;
    }

    const object = new THREE.Mesh(geometry, material);
    object.position.set(x, y, z);
    scene.add(object);
    return object;
}


function createGridOfCubes() {
    const geometryTypes = [
        'sphere',
        'torus',
        'cone',
        'tetrahedron',
        'cylinder',
        'icosahedron',
        'octahedron',
        'torusKnot',
        'dodecahedron'
    ];

    const gridSize = 9;
    const cubeDistance = cubeSize + 60;

    for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
            for (let z = 0; z < gridSize; z++) {
                const xPos = x * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;
                const yPos = y * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;
                const zPos = z * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;

                // Use the geometry type from the geometryTypes array corresponding to the z index
                const geometryType = geometryTypes[z];

                createCubeWithSphere(xPos, yPos, zPos, 0.5, geometryType);
            }
        }
    }
}


        function createGridOfCubesWithSpheres(size) {
            const grid = [];
            const offset = Math.floor(size / 2) * cubeDistance;
            for (let x = -offset; x <= offset; x += cubeDistance) {
                for (let y = -offset; y <= offset; y += cubeDistance) {
                    for (let z = -offset; z <= offset; z += cubeDistance) {
                        const opacity = (x === 0 && y === 0 && z === 0) ? 0.5 : 1;
                        const cubeWithSphere = createCubeWithSphere(x, y, z, opacity);
                        grid.push(cubeWithSphere);
                    }
                }
            }
            return grid;
        }

        const gridOfCubesWithSpheres = createGridOfCubes(9);

        camera.position.z = 300;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let clickedObject = null;

        function animate() {
            requestAnimationFrame(animate);

            gridOfCubesWithSpheres.forEach(obj => {
                obj.cube.rotation.x += 0.01;
                obj.cube.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
        }

async function onDocumentMouseDown(event) {
    event.preventDefault();
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
        clickedObject = intersects[0].object;

        if (clickedObject.geometry.type === "BoxGeometry") {
            const parentCube = clickedObject.userData.parentCube;
            const targetPosition = parentCube.position.clone().add(new THREE.Vector3(0, 0, cubeSize * 2.5));

            // Animate camera position using Tween.js with a slower zoom (3 seconds)
            const tween = new TWEEN.Tween(camera.position)
                .to(targetPosition, 3000)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate(() => {
                    controls.update();
                })
                .start();

            controls.target.copy(parentCube.position);

            // Play sound with the frequency stored in the clicked cube
            const synth = new Tone.Synth().toDestination();
            await Tone.start();
            synth.triggerAttackRelease(parentCube.userData.frequency, "8n");
        }
    }
}

        function animate() {
            requestAnimationFrame(animate);

            // ...

            TWEEN.update();

            renderer.render(scene, camera);
        }


        animate();
        window.addEventListener('mousedown', onDocumentMouseDown, false);

    </script>
</body>
</html>
