<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metacube</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        .login-section {
              position: fixed;
              top: 0;
              left: 0;
              right: 0;
              height: 50px;
              background-color: #333;
              display: flex;
              align-items: center;
              justify-content: flex-end;
              padding-right: 20px;
            }

            button {
              background-color: #171a21;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 10px 20px;
              font-size: 16px;
              cursor: pointer;
            }

            button:hover {
              background-color: #1d1f27;
        }

    </style>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.30/Tone.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
<!-- <script src="https://steamcommunity.com/public/javascript/webui/webui.js"></script> -->


</head>
<body>


    <script>

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        const cubeSize = 10;
        const cubeDistance = 60;

        function createSphere(x, y, z, radius, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            scene.add(sphere);
            return sphere;
        }

        function createCubeWithSphere(x, y, z, opacity, geometryType) {
            // const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });
            // const cube = new THREE.Mesh(geometry, material);
            const edgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize));
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });
            const cube = new THREE.LineSegments(edgesGeometry, lineMaterial);

            const smallCubeSize = cubeSize / 100;
            const smallCubeGeometry = new THREE.BoxGeometry(smallCubeSize, smallCubeSize, smallCubeSize);
            const smallCubeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const smallCube = new THREE.Mesh(smallCubeGeometry, smallCubeMaterial);
            smallCube.position.set(x, y, z);
            scene.add(smallCube);

            cube.position.set(x, y, z);
            scene.add(cube);


            // Store a random frequency for each cube
            cube.userData.frequency = 440 * Math.pow(2, (Math.floor(Math.random() * 12) - 9) / 12);

            const uniqueObject = createUniqueObject(x, y, z, geometryType);

                // Create an invisible mesh for click detection
            const invisibleMeshGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const invisibleMeshMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const invisibleMesh = new THREE.Mesh(invisibleMeshGeometry, invisibleMeshMaterial);
            invisibleMesh.position.set(x, y, z);
            scene.add(invisibleMesh);

            invisibleMesh.userData.parentCube = cube;

            return { cube, uniqueObject, invisibleMesh, smallCube };
        }


function createUniqueObject(x, y, z, type) {
    let geometry;

    // Calculate the distance between the geometry and the center of the grid
    const center = new THREE.Vector3(0, 0, 0);
    const currentPosition = new THREE.Vector3(x, y, z);
    const distanceToCenter = currentPosition.distanceTo(center);

    // Calculate the maximum possible distance
    const gridSize = 9;
    const cubeDistance = cubeSize + 60;
    const maxDistance = Math.sqrt(Math.pow((gridSize * cubeDistance) / 2, 2) * 3);

    // Generate a shade of purple based on the distance to the center
    const lightness = Math.floor((distanceToCenter / maxDistance) * 100);
    const purpleColor = new THREE.Color(`hsl(270, 100%, ${lightness}%)`);

    const material = new THREE.MeshBasicMaterial({ color: purpleColor });

    switch (type) {
        case 'sphere':
            geometry = new THREE.SphereGeometry(cubeSize / 2, 32, 32);
            break;
        case 'torus':
            geometry = new THREE.TorusGeometry(cubeSize / 4, cubeSize / 8, 16, 100);
            break;
        case 'tetrahedron':
            geometry = new THREE.TetrahedronGeometry(cubeSize / 2);
            break;
        case 'cone':
            geometry = new THREE.ConeGeometry(cubeSize / 2, cubeSize, 32);
            break;
        case 'cylinder':
            geometry = new THREE.CylinderGeometry(cubeSize / 2, cubeSize / 2, cubeSize, 32);
            break;
        case 'icosahedron':
            geometry = new THREE.IcosahedronGeometry(cubeSize / 2);
            break;
        case 'octahedron':
            geometry = new THREE.OctahedronGeometry(cubeSize / 2);
            break;
        case 'torusKnot':
            geometry = new THREE.TorusKnotGeometry(cubeSize / 4, cubeSize / 8, 100, 16);
            break;
        case 'dodecahedron':
            geometry = new THREE.DodecahedronGeometry(cubeSize / 2);
            break;
    }

    const object = new THREE.Mesh(geometry, material);
    object.scale.set(.5, .5, .5);

    object.position.set(x, y, z);
    scene.add(object);
    return object;
}


const cubeObjects = [];


function createGridOfCubes() {
    const geometryTypes = [
        'sphere',
        'torus',
        'cone',
        'tetrahedron',
        'cylinder',
        'icosahedron',
        'octahedron',
        'torusKnot',
        'dodecahedron'
    ];

    const gridSize = 9;
    const cubeDistance = cubeSize + 60;

    for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
            for (let z = 0; z < gridSize; z++) {
                const xPos = x * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;
                const yPos = y * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;
                const zPos = z * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;

                // Use the geometry type from the geometryTypes array corresponding to the z index
                const geometryType = geometryTypes[z];

                createCubeWithSphere(xPos, yPos, zPos, 0.5, geometryType);
            }
        }
    }
}


        function createGridOfCubesWithSpheres(size) {
            const grid = [];
            const offset = Math.floor(size / 2) * cubeDistance;
            for (let x = -offset; x <= offset; x += cubeDistance) {
                for (let y = -offset; y <= offset; y += cubeDistance) {
                    for (let z = -offset; z <= offset; z += cubeDistance) {
                        const opacity = (x === 0 && y === 0 && z === 0) ? 0.5 : 1;
                        const cubeWithSphere = createCubeWithSphere(x, y, z, opacity);
                        grid.push(cubeWithSphere);
                    }
                }
            }
            return grid;
        }

        const gridOfCubesWithSpheres = createGridOfCubes(9);

        camera.position.z = 300;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let clickedObject = null;

        function animate() {
            requestAnimationFrame(animate);

            gridOfCubesWithSpheres.forEach(obj => {
                obj.cube.rotation.x += 0.01;
                obj.cube.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
        }

async function onDocumentMouseDown(event) {
    event.preventDefault();
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
        clickedObject = intersects[0].object;

        if (clickedObject.geometry.type === "BoxGeometry") {
            const parentCube = clickedObject.userData.parentCube;
            const targetPosition = parentCube.position.clone().add(new THREE.Vector3(0, 0, cubeSize * 2.5));

            // Animate camera position using Tween.js with a slower zoom (3 seconds)
            const tween = new TWEEN.Tween(camera.position)
                .to(targetPosition, 3000)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate(() => {
                    controls.update();
                })
                .start();

            controls.target.copy(parentCube.position);

            // Play sound with the frequency stored in the clicked cube
            const synth = new Tone.Synth().toDestination();
            await Tone.start();
            synth.triggerAttackRelease(parentCube.userData.frequency, "8n");
        }
    }
}

        let edgeFadeDirection = 1;
        let edgeOpacity = 0;


        function animate() {
                requestAnimationFrame(animate);

                // Fade the edges in and out
                edgeOpacity += edgeFadeDirection * 0.01;
                if (edgeOpacity >= 1) {
                    edgeFadeDirection = -1;
                } else if (edgeOpacity <= 0) {
                    edgeFadeDirection = 1;
                }

            scene.traverse(child => {
                if (child.isMesh && child.material instanceof THREE.LineBasicMaterial) {
                    child.material.opacity = edgeOpacity;
                    child.material.transparent = true;
                    child.material.needsUpdate = true;
                } else if (child.isMesh) {
                    child.rotation.x += 0.002;
                    child.rotation.y += 0.002;
                }
            });

            TWEEN.update();

            renderer.render(scene, camera);
            controls.update();

        }


const pointLight = new THREE.PointLight(0xffffff, 0.5);
pointLight.position.set(0, 0, 100);
scene.add(pointLight);

        animate();
        window.addEventListener('mousedown', onDocumentMouseDown, false);

    </script>

    <script>


// Replace 'YOUR_API_KEY' with your actual Steam Web API key
const API_KEY = '633FAC6F87C73A7A24676D7C4D4D6AC0';

// Initiate Steam login and handle the response
function steamLogin() {
  var login = new SteamLogin();
  login.openidPopup('https://steamcommunity.com/openid/', 'https://yourwebsite.com/auth', handleLoginResponse);
}

// Handle the login response
function handleLoginResponse(response) {
  if (response && response.oauth_token) {
    // The user has successfully logged in
    // You can now use the Steam Web API to access the user's information
    const oauthToken = response.oauth_token;
    getUserInfo(oauthToken);
  } else {
    // The user has canceled the login process
  }
}

// Retrieve the user's information from the Steam Web API
function getUserInfo(oauthToken) {
  const url = `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=${API_KEY}&format=json&access_token=${oauthToken}`;
  fetch(url)
    .then(response => response.json())
    .then(data => {
      // Parse the response to get the user's information
      const userInfo = data.response.players[0];
      console.log(userInfo);
    })
    .catch(error => {
      console.error(error);
    });
}

    </script>

<div class="login-section">
  <img  onclick="steamLogin()" src="img/steam-login.png"/>
</div>

</body>
</html>
