<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metacube</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        .login-section {
              overflow: scroll;
              /* position: fixed; */
              top: 0;
              left: 0;
              right: 0;
              height: 50px;
              display: flex;
              align-items: center;
              justify-content: flex-end;
              padding-right: 20px;  
            }

            button {
              background-color: #171a21;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 10px 20px;
              font-size: 16px;
              cursor: pointer;
            }

            button:hover {
              background-color: #1d1f27;
        }

        #terminal {
            width: 100%;
            background-color: black;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;

          }


    </style>


<!-- <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.30/Tone.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-webgl/lib/xterm-addon-webgl.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" /> -->


<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/Tone.js"></script>
<script src="js/tween.umd.min.js"></script>
<script src="js/FileSaver.min.js"></script>
<script src="js/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>
<script src="js/xterm.js"></script>
<script src="js/xterm-addon-fit.js"></script>
<script src="js/xterm-addon-webgl.js"></script>
<link rel="stylesheet" href="css/xterm.css" />


<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


<script>
    var mol = "S 1 2 3^K 3^K 2";
    // var mol = "chemSKI rewrite terminSK. The node S plays two roles: as the combinator S and as a fanout. The node K behaves as combinator K but also as a termination.</a>";

</script>

<!-- <link rel="stylesheet" type="text/css" href="css/icequine-on-white.css"> -->

</head>
<body>

<!-- 
    <div class="login-section">

      
        <div class="row">
          <div class="col-2 menu">
          </div>
          <div class="col-7 menu">
          </div>
          <div class="col-3 menu" style="text-align: left;">
          </div>
        </div>
        
        <div class="row">
          <div class="col-2 menu">
            <div class="scol-12"> <span3  id="button1" class="image2" ></span3></div>
            <div class="scol-12"> <span3  id="button2" class="image2" ></span3></div>
            <div class="scol-12"> <span3  id="button3" class="image2" ></span3></div>
          </div>
          <div class="col-7 menu">
            <ul>
              <li> <div id="svgdiv"> </div></li>
              <li><span3>gravity slider</span3> <div class="slidecontainer">MIN &nbsp;<input class="slider" type="range" min="1" max="250" value="150" id="gravRange"> &nbsp; MAX</div></li>
              <li><span2>CODE: </span2><span id="molyoulookat"></span></li>
              <li><span> (Rewrites stop at max.  </span><span id="maxnodenumber">1024</span> nodes<span>)</span></li>
            </ul>
          </div>
          <div class="col-3 menu" style="text-align: left;">
            <span id="comments" ></span>
          </div>
        </div>
        
        <div class="row">
              <div class="scol-6" style="text-align: left;">
                <span2>before:</span2><br><br>
                <span id="puttransformcachealt"></span>
              </div> 
              <div class="scol-6" style="text-align: left;">
                <span2>chosen:</span2><br><br>
                <span id="chosentransform"></span>
              </div>
              <div class="scol-6" style="text-align: left;">
                <span2>after:</span2><br><br>
                <span id="puttransformcachealtafter"></span>
              </div>
            <div class="scol-6" style="text-align: left;">
              <span2>mol before:</span2><br><br>
              <span id="molexport"></span>
            </div>
            <div class="scol-6" style="text-align: left;">
              <span2>mol after:</span2><br><br>
              <span id="molexportafter"></span>
            </div>
        </div>
        



       <input type="text" value="cheese" /> 
      <img src="img/space-monet.png" width="2px"/> <div id="balance" style="color:white; text-align:left">0 </div>
  <input id="journeyData" value="your journey data here"  type="text" onchange="playJourney()" size="20"/>
      <button id="loginWithMetamask">Login</button> 
    
    <img  onclick="playJourney()" src="img/steam-login.png"/>


    </div>-->
    <div id="terminal">



      
    </div>



    <div id="hypercube"></div>

    <script>

        var allVisitedCubes = {};
        var allCubes = [];
        const socket = io();
        var credits = 10;
        var selectedCubeIndex = 172;

        // TODO: I think this doesn't work becauese scene hasn't rendered :(

        socket.on('visitedCubes', visitedCubes => {

              // console.log("cubesinbound:" + visitedCubes.length);
              // console.log(visitedCubes);
              allVisitedCubes = visitedCubes;

              Object.keys(allVisitedCubes).forEach(cubeId => {
                // console.log("updating " + cubeId);


              var thiscube = scene.getObjectByProperty("uuid", cubeId);
              //  always undefined
              console.log(thiscube);
              if (thiscube) {
                  console.log("segmenting " + cubeId);

                const outline = thiscube.getObjectByProperty("type", "LineSegments");
                if (outline) {
                    console.log("bluying " + cubeId);

                  outline.material.color.set("blue");
                }
          }
        });
     });



        socket.on("cubeVisited", (cubeId) => {

        // console.log("visit:" + cubeId);

          const cube = scene.getObjectByProperty("uuid", cubeId);
          if (cube) {
            const outline = cube.getObjectByProperty("type", "LineSegments");
            if (outline) {
                     console.log("blue-ing visited " + cubeId);
                    selectedCubeIndex = cubeId;
                    // selectedCube.xPos;

                    outline.material.color.set("blue");
                    const synth = new Tone.Synth().toDestination();
                    Tone.start();
                    if (cubeId == 63)
                       enterMinkowskiSound();
                    else 
                      synth.triggerAttackRelease(cube.userData.frequency, "8n");


            }
          }
        });



        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        const cubeSize = 10;
        const cubeDistance = 60;

        const textureLoader = new THREE.TextureLoader();
        // const imageTexture = textureLoader.load('img/jd.jpeg');


    const textures = [
      textureLoader.load('https://f8n-production.imgix.net/creators/profile/47zx5exuz-cryptoapollo-jpg-hgsplk.jpg?auto=format%2Ccompress&q=50&w=128&h=128&fit=crop&dpr=2'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0xB7A1E2282974a42BC30D36eBdc7E7BcdcB8E4d28/28/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0x70fB56F898E44D70C1f7C1E2a9ca14c33cFDC6c5/5/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0x866b27fc857D16Aaaf7e2f7846EFe95747385fE0/3/nft.png?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0x93A430DfFDC5f79D2d8Ca574C137a124aD1a21C4/4/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0x79aB1115533B86d032BEA40ce63eB74E323f9eA4/1/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0xbc342b06b912C50eAc9C094b10cd2B8d30152d2b/3/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0xABB3738f04Dc2Ec20f4AE4462c3d069d02AE045B/11542018/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0xBda03C0C791b80061B90F176E6F45E685A94C36c/4/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('/img/ai/1.jpeg'),
      textureLoader.load('/img/ai/2.jpeg'),
      textureLoader.load('/img/ai/3.jpeg'),
      textureLoader.load('/img/ai/4.png'),
      textureLoader.load('/img/ai/5.jpeg'),
      textureLoader.load('/img/ai/6.jpeg'),
      textureLoader.load('/img/ai/7.jpeg'),
      textureLoader.load('/img/ai/8.png'),
      textureLoader.load('/img/ai/9.jpeg'),
      textureLoader.load('/img/ai/10.jpeg'),
      textureLoader.load('/img/ai/11.png'),
      textureLoader.load('/img/ai/12.png'),
      textureLoader.load('/img/ai/13.jpeg'),
      textureLoader.load('/img/ai/14.png'),
      textureLoader.load('/img/ai/15.png'),
      textureLoader.load('/img/ai/16.png'),
      textureLoader.load('/img/ai/17.png'),
      textureLoader.load('/img/ai/18.png'),
      textureLoader.load('/img/ai/19.jpeg'),
      textureLoader.load('/img/ai/20.jpeg'),
      textureLoader.load('/img/ai/21.jpeg'),
      textureLoader.load('/img/ai/22.jpeg'),
      textureLoader.load('/img/ai/23.png')


    ];

    

        // const imageTexture = textureLoader.load('https://i.seadn.io/gae/9PTBw2m23Lrcol5YURG7iIIgKgYTPUO77FekvX1JyMIEzBK5mayjLWH00WFPHOP0OqJF7f3Xr9E2kxuXIiHJXViw7qHB6_mqBZYnx5c?auto=format&w=2048');


        // var labelRenderer = new CSS3DRenderer();
        // labelRenderer.setSize( innerWidth, innerHeight );
        // labelRenderer.domElement.style.position = 'absolute';
        // labelRenderer.domElement.style.top = '0px';
        // document.body.appendChild( labelRenderer.domElement );



        function createSphere(x, y, z, radius, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            scene.add(sphere);
            return sphere;
        }

    function getRandomTexture() {
      const index = Math.floor(Math.random() * textures.length);
      return textures[index];
    }

        function createCubeWithUniqueObject(x, y, z, opacity, geometryType, cubeNumber, modelUrl) {

                if (modelUrl) {
                        loadModel(modelUrl, smallCube);
                }

            // const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });
            // const cube = new THREE.Mesh(geometry, material);
            const edgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize));
            var lineMaterial;
            // console.log(allVisitedCubes);
            if(allVisitedCubes[cubeNumber])
                lineMaterial = new THREE.LineBasicMaterial({ color: blue, transparent: true, opacity: opacity });
            else
                lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });

            const cube = new THREE.LineSegments(edgesGeometry, lineMaterial);
            cube.uuid = cubeNumber;
            cube.label = "";

            const smallEdgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(.2, .2, .2));

            const smallCube = new THREE.LineSegments(smallEdgesGeometry, lineMaterial);

            smallCube.position.set(x+3, y+3, z+3);
            scene.add(smallCube);


            const imageDisplay = createImageDisplay(getRandomTexture());

            // Position the image display inside the cube
            imageDisplay.position.set(x-4, y-4, z-4);
            // imageDisplay.rotation.y = Math.PI / 4;
            // imageDisplay.offset.y = 1;
            // imageDisplay.repeat.y = -1;

            // Add the image display to the cube
            scene.add(imageDisplay);


            cube.position.set(x, y, z);
            scene.add(cube);

// CSS3DObject not loading 
            // var div = document.createElement( 'div' );
            // div.className = 'label';
            // div.textContent = '1';
            // var label = new CSS3DObject( div );
            // label.position.copy(pos);
            // label.rotation.y = Math.PI * 0.5;
            // label.scale.set(0.025, 0.025, 1);
            // cube.add( label );



            // Store a random    for each cube
            // TODO: update this 
            cube.userData.frequency = 440 * Math.pow(2, (Math.floor(Math.random() * 12) - 9) / 12);

            const uniqueObject = createUniqueObject(x, y, z, geometryType);
            var textLabel;
            if (cube.name && cube.name.length > 2)
            {
              textLabel = cube.name;
            }
            else {
                textLabel=  createTextLabel(`Cube ${cubeNumber} ${uniqueObject.name}`);
           }

          // const textLabel = createTextLabel(`Cube 22: ${uniqueObject.name}`);

          textLabel.position.set(5.5, 0, 0); // Position the text label on the side of the cube
          cube.add(textLabel);
                // Create an invisible mesh for click detection
            const invisibleMeshGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const invisibleMeshMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const invisibleMesh = new THREE.Mesh(invisibleMeshGeometry, invisibleMeshMaterial);
            invisibleMesh.position.set(x, y, z);
            scene.add(invisibleMesh);

            invisibleMesh.userData.parentCube = cube;
            allCubes.push(cube);  
            return { cube, uniqueObject, invisibleMesh, smallCube };
        }


function createUniqueObject(x, y, z, type) {
    let geometry;

    // Calculate the distance between the geometry and the center of the grid
    const center = new THREE.Vector3(0, 0, 0);
    const currentPosition = new THREE.Vector3(x, y, z);
    const distanceToCenter = currentPosition.distanceTo(center);

    // Calculate the maximum possible distance
    const gridSize = 9;
    const cubeDistance = cubeSize + 60;
    const maxDistance = Math.sqrt(Math.pow((gridSize * cubeDistance) / 2, 2) * 3);

    // Generate a shade of purple based on the distance to the center
    const lightness = Math.floor((distanceToCenter / maxDistance) * 110);
    const purpleColor = new THREE.Color(`hsl(270, 100%, ${lightness}%)`);

    const material = new THREE.MeshBasicMaterial({ color: purpleColor });

    switch (type) {
        case 'sphere':
            geometry = new THREE.SphereGeometry(cubeSize / 2, 32, 32);
            break;
        case 'torus':
            geometry = new THREE.TorusGeometry(cubeSize / 4, cubeSize / 8, 16, 100);
            break;
        case 'tetrahedron':
            geometry = new THREE.TetrahedronGeometry(cubeSize / 2);
            break;
        case 'cone':
            geometry = new THREE.ConeGeometry(cubeSize / 2, cubeSize, 32);
            break;
        case 'cylinder':
            geometry = new THREE.CylinderGeometry(cubeSize / 2, cubeSize / 2, cubeSize, 32);
            break;
        case 'icosahedron':
            geometry = new THREE.IcosahedronGeometry(cubeSize / 2);
            break;
        case 'octahedron':
            geometry = new THREE.OctahedronGeometry(cubeSize / 2);
            break;
        case 'torusKnot':
            geometry = new THREE.TorusKnotGeometry(cubeSize / 4, cubeSize / 8, 100, 16);
            break;
        case 'dodecahedron':
            geometry = new THREE.DodecahedronGeometry(cubeSize / 2);
            break;
    }

    const object = new THREE.Mesh(geometry, material);
    object.scale.set(.3, .3, .3);
    object.position.set(x, y, z);
    scene.add(object);
    return object;
}


const cubeObjects = [];
var analyser;
var dataArray;
var bufferLength;
var beethovenText;
var cubeMap = new Map(); // Store the cubes with coordinates as keys
var cubeLabels = new Map(); // Store the cubes with labels as keys



// var cubesByGeometry = [][];

function loadModel(url, parentObject) {
    const loader = new THREE.GLTFLoader();

    loader.load(url, (gltf) => {
        const model = gltf.scene;
        model.scale.set(0.01, 0.01, 0.01); // Scale down the model
        model.position.set(0, 0, 0); // Center the model inside the cube
        parentObject.add(model);
    });
}




function createGridOfCubes() {
    const geometryTypes = [
        'icosahedron',
        'dodecahedron',
        'octahedron',
        'tetrahedron',
        'torus',
        'cone',
        'torusKnot',
        'sphere',
        'sphere'


    ];

    
        const gridSize = 7;
        const cubeDistance = cubeSize + 60;
        var cubeNumber = 1;
        const cubeSpacing = 60;


        for (let x = -Math.floor(gridSize / 2); x <= Math.floor(gridSize / 2); x++) {
  for (let y = -Math.floor(gridSize / 2); y <= Math.floor(gridSize / 2); y++) {
    for (let z = -Math.floor(gridSize / 2); z <= Math.floor(gridSize / 2); z++) {
     const geometryType = geometryTypes[z];

      // const activeCube =createCubeWithUniqueObject(xPos + 30, yPos + 30, zPos + 30, 0.5, geometryType, cubeNumber);
      const activeCube =createCubeWithUniqueObject(x * (cubeSize + cubeSpacing), y * (cubeSize + cubeSpacing), z * (cubeSize + cubeSpacing), 0.5, geometryType, cubeNumber);

      // Save the cube in the cubes map with its coordinates as the key
      const key = `${x},${y},${z}`;
      cubeMap.set(key, activeCube);
      cubeNumber++;
    }
  }
}

}


//     for (let x = 0; x < gridSize; x++) {
//         for (let y = 0; y < gridSize; y++) {
//             for (let z = 0; z < gridSize; z++) {
//                 const xPos = x * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;
//                 const yPos = y * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;
//                 const zPos = z * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;

//                 // Use the geometry type from the geometryTypes array corresponding to the z index
//                 const geometryType = geometryTypes[z];

//                 const activeCube =createCubeWithUniqueObject(xPos + 30, yPos + 30, zPos + 30, 0.5, geometryType, cubeNumber);
//                 const key = `${x},${y},${z}`;
//                 cubeMap.set(key, activeCube);
  
//                 cubeNumber++; 
//             }
//         }

//     }
// }


        function getCubeByCoordinates(x, y, z) {
          const key = `${x},${y},${z}`;
          return cubeMap.get(key);
        }

        function getCubeIndexByCoordinates(x, y, z) {
          const key = `${x},${y},${z}`;
          return cubeMap.get(key).uuid;
        }


        function createGridOfCubesWithSpheres(size) {
            const grid = [];
            const offset = Math.floor(size / 2) * cubeDistance;
            for (let x = -offset; x <= offset; x += cubeDistance) {
                for (let y = -offset; y <= offset; y += cubeDistance) {
                    for (let z = -offset; z <= offset; z += cubeDistance) {
                        const opacity = (x === 0 && y === 0 && z === 0) ? 0.5 : 1;
                        const cubeWithSphere = createCubeWithUniqueObject(x, y, z, opacity);
                        grid.push(cubeWithSphere);
                    }
                }
            }
            return grid;
        }

        const gridOfCubesWithSpheres = createGridOfCubes(9);

        camera.position.z = 300;

        const raycaster = new THREE.Raycaster();
        const clickableObjects = [];

        const mouse = new THREE.Vector2();
        let clickedObject = null;

        // function animate() {
        //     requestAnimationFrame(animate);

        //     gridOfCubesWithSpheres.forEach(obj => {
        //         obj.cube.rotation.x += 0.01;
        //         obj.cube.rotation.y += 0.01;
        //     });

        //     renderer.render(scene, camera);
        // }

async function onDocumentMouseDown(event) {
    event.preventDefault();
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
        clickedObject = intersects[0].object;

        if (clickedObject.geometry.type === "BoxGeometry") {
            const parentCube = clickedObject.userData.parentCube;
            const targetPosition = parentCube.position.clone().add(new THREE.Vector3(0, 0, cubeSize * 2.5));

            // Animate camera position using Tween.js with a slower zoom (3 seconds)
            const tween = new TWEEN.Tween(camera.position)
                .to(targetPosition, 3000)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate(() => {
                    controls.update();

                })
                .start();

            // When an object in the scene is manipulated, send an update to the server
            // socket.emit("sceneUpdate", "visiting ");
                // console.log(parentCube.uuid);
            socket.emit("cubeVisited", parentCube.uuid);
            // const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            // const audioElement = new Audio('beethoven_op131_allegro_001.mp3');
            // const sourceNode = audioContext.createMediaElementSource(audioElement);
            // analyser = audioContext.createAnalyser();
            // sourceNode.connect(analyser);
            // analyser.fftSize = 256; // Set the FFT size (power of 2, default is 2048)
            // sourceNode.connect(audioContext.destination);


            // audioElement.play();
            // analyzeFrequencyAndHighlightCubes();

            controls.target.copy(parentCube.position);
            // takeSnapshot(parentCube);


            // Play sound with the frequency stored in the clicked cube
            // const synth = new Tone.Synth().toDestination();
            // await Tone.start();
            // synth.triggerAttackRelease(parentCube.userData.frequency, "8n");
        }
    }
}

        let edgeFadeDirection = 1;
        let edgeOpacity = 0;

        // In your Three.js script
        function checkForVisitedCubes() {
          const thresholdDistance = 50; // Adjust this value as needed

          for (const cube of cubeObjects) {
            const distance = cursor.position.distanceTo(cube.position);
            if (distance < thresholdDistance) {
              socket.emit("cubeVisited", cube.uuid);
              break;
            }
          }
        }



        function animate() {


                requestAnimationFrame(animate);

                // Fade the edges in and out
                // edgeOpacity += edgeFadeDirection * 0.01;
                // if (edgeOpacity >= 1) {
                //     edgeFadeDirection = -1;
                // } else if (edgeOpacity <= 0) {
                //     edgeFadeDirection = 1;
                // }

            scene.traverse(child => {
                if (child.isMesh && child.material instanceof THREE.LineBasicMaterial) {
                    child.material.opacity = edgeOpacity;
                    child.material.transparent = true;
                    child.material.needsUpdate = true;
                } else if (child.isMesh) {
                    // child.rotation.x += 0.002;
                    // child.rotation.y += 0.002;
                }
            });

            checkForVisitedCubes();

            TWEEN.update();

            renderer.render(scene, camera);
            controls.update();

        }


const pointLight = new THREE.PointLight(0xffffff, 0.5);
pointLight.position.set(0, 0, 100);
scene.add(pointLight);

        animate();
        window.addEventListener('mousedown', onDocumentMouseDown, false);

<!-- JSONparser section --> 

// Sample JSON from Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e
// URL https://jmkre9md1i.execute-api.eu-central-1.amazonaws.com/stage/land/Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e/assets

var jsonString='{"message":"Success","data":{"items":[{"verticesCount":1949,"rotation":"P=0.000000 Y=90.000000 R=-0.000000","objectId":"SM_Eris_01","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-1a86ac5d-b6d6-4b21-a1c5-06fee764d868-896ac586-85f0-44f4-82b8-5d969ef810fe","thumbnail":{"url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/3041b2cf-9fe3-4df6-8474-8493ea7711cc/SM_Eris_01.jpg","id":"File-3041b2cf-9fe3-4df6-8474-8493ea7711cc"},"description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/1a86ac5d-b6d6-4b21-a1c5-06fee764d868/SM_Eris_01.glb","position":"X=155339.335 Y=-253611.600 Z=107672.749","scale":"X=100.000 Y=100.000 Z=100.000","title":"SM_Eris_01.glb"},{"verticesCount":1949,"rotation":"P=0.000000 Y=90.000000 R=-0.000000","objectId":"SM_Sun_01","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-2c30b72d-f741-4cda-83fa-9d29a2fc69be-063d65ae-1a24-4366-91a5-6b37347f5e0a","thumbnail":{"url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/2d53de48-a259-479e-b2c6-a12f2f102862/SM_Sun_01.jpg","id":"File-2d53de48-a259-479e-b2c6-a12f2f102862"},"description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/2c30b72d-f741-4cda-83fa-9d29a2fc69be/SM_Sun_01.glb","position":"X=215512.640 Y=-202823.598 Z=156554.052","scale":"X=100.000 Y=100.000 Z=100.000","title":"SM_Sun_01.glb"},{"verticesCount":1949,"rotation":"P=0.000000 Y=90.000000 R=-0.000000","objectId":"SM_Moon_01","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-333c34d5-eb27-4175-be8f-cae87aa0d855-4fda87fd-d256-49b0-9f73-044c4ce38103","thumbnail":{"url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/ccc78f73-3235-40dc-85c1-1aba2dbf8b57/SM_Moon_01.jpg","id":"File-ccc78f73-3235-40dc-85c1-1aba2dbf8b57"},"description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/333c34d5-eb27-4175-be8f-cae87aa0d855/SM_Moon_01.glb","position":"X=136794.360 Y=-253178.753 Z=128042.662","scale":"X=100.000 Y=100.000 Z=100.000","title":"SM_Moon_01.glb"},{"verticesCount":0,"rotation":"P=0.000000 Y=180.000000 R=0.000000","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-8c9e0cda-03eb-43c0-85d3-2d10fd88a36d-85522845-c0ac-499d-978c-10b97ae92de8","description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/8c9e0cda-03eb-43c0-85d3-2d10fd88a36d/VR_blob3g.fbx","position":"X=7949.289 Y=-173781.646 Z=-422593.657","scale":"X=0.000 Y=0.000 Z=0.000","title":"VR_blob3g.fbx"},{"verticesCount":11859,"rotation":"P=0.000000 Y=90.000000 R=-0.000000","objectId":"Snow","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-b739c4eb-2f74-442e-93cd-e295e66fbc7a-717a9f44-8726-4884-92eb-1bfd156907c7","thumbnail":{"url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/fce0662c-7c5e-4f71-a863-3450f32dd773/Snow.jpg","id":"File-fce0662c-7c5e-4f71-a863-3450f32dd773"},"description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/b739c4eb-2f74-442e-93cd-e295e66fbc7a/Snow.glb","position":"X=0.000 Y=0.000 Z=-16940.967","scale":"X=100.000 Y=100.000 Z=100.000","title":"Snow.glb"}]}}';

function JSONparser(jsonString)  {
        // Parse the JSON data
        const jsonData = JSON.parse(jsonString);

        // Choose an item from the "items" array in the JSON data
        const item = jsonData.data.items[0]; // Select the first item in the array

        // Extract the model URL, position, and scale from the item
        const modelUrl = item.url;

        // Parse the position string and extract the X, Y, and Z values
        const positionMatch = item.position.match(/X=(-?\d+(\.\d+)?) Y=(-?\d+(\.\d+)?) Z=(-?\d+(\.\d+)?)/);
        const posX = parseFloat(positionMatch[1]);
        const posY = parseFloat(positionMatch[3]);
        const posZ = parseFloat(positionMatch[5]);

        // Parse the scale string and extract the X, Y, and Z values
        const scaleMatch = item.scale.match(/X=(-?\d+(\.\d+)?) Y=(-?\d+(\.\d+)?) Z=(-?\d+(\.\d+)?)/);
        const scaleX = parseFloat(scaleMatch[1]);
        const scaleY = parseFloat(scaleMatch[3]);
        const scaleZ = parseFloat(scaleMatch[5]);

        // Replace these variables with the actual values you want to use
        const targetOpacity = 0.5;
        const targetGeometryType = 'BoxGeometry';



    // Call the createCubeWithUniqueObject function with the model URL as an argument
    const cube = createCubeWithUniqueObject(scene, targetX, targetY, targetZ, targetOpacity, targetGeometryType, 1, modelUrl);

}


<!-- login section --> 
var activeUser = "";

async function loginWithMetaMask() {
  // Check if MetaMask is installed
  if (typeof window.ethereum === "undefined") {
    alert("Please install MetaMask to use this feature.");
    return;
  }

  try {
    // Request the user's Ethereum address
    const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
    const userAddress = accounts[0];
    activeUser = userAddress;
    // Use the Ethereum address as a unique identifier for the user
    console.log("User's Ethereum address:", userAddress);
    socket.emit("ethAddress", userAddress);


      try {
      const response = await fetch(`/balance/${userAddress}`);
      if (response.ok) {
        const data = await response.json();
        const balance = data.balance;
        console.log('Balance:', balance);
        // Display the balance on the page, e.g., update the DOM with the balance value
      } else {
        console.error('Error fetching balance:', response.statusText);
      }
    } catch (error) {
      console.error('Error fetching balance:', error);
    }

    // const balance = await getUserBalance(userAddress);
    // updateBalanceDisplay(balance);


    // Authenticate the user and proceed with your app's login flow
    // Example: store the user's Ethereum address in a cookie or session, fetch user data from your server, etc.
  } catch (error) {
    console.error("Error logging in with MetaMask:", error);
    alert("Login with MetaMask failed.");
  }
}


<!--  Does not work out of box from GPT-4 seems to require a generic openID oauth libary --> 

// Add a click event listener to the MetaMask login button
// document.getElementById("loginWithMetamask").addEventListener("click", loginWithMetaMask);

// Replace 'YOUR_API_KEY' with your actual Steam Web API key
const API_KEY = '633FAC6F87C73A7A24676D7C4D4D6AC0';

// Initiate Steam login and handle the response
function steamLogin() {
  playJourney();
  // var login = new SteamLogin();
  // login.openidPopup('https://steamprospera.com/openid/', 'https://yourwebsite.com/auth', handleLoginResponse);
}

// Handle the login response
function handleLoginResponse(response) {
  if (response && response.oauth_token) {
    // The user has successfully logged in
    // You can now use the Steam Web API to access the user's information
    const oauthToken = response.oauth_token;
    getUserInfo(oauthToken);
  } else {
    // The user has canceled the login process
  } 
}

// Retrieve the user's information from the Steam Web API
function getUserInfo(oauthToken) {
  const url = `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=${API_KEY}&format=json&access_token=${oauthToken}`;
  fetch(url)
    .then(response => response.json())
    .then(data => {
      // Parse the response to get the user's information
      const userInfo = data.response.players[0];
      console.log(userInfo);
    })
    .catch(error => {
      console.error(error);
    });
}


<!-- SECTION: image manipulation libaray  --> 




function createImageDisplay(imageTexture) {
  const geometry = new THREE.PlaneGeometry(3, 3);
  const material = new THREE.MeshBasicMaterial({ map: imageTexture, transparent: true });
  const imageDisplay = new THREE.Mesh(geometry, material);
  
  return imageDisplay;
}


function createTextTexture(text) {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');

  canvas.width = 256;
  canvas.height = 256;

  // Draw a background (optional)
  context.fillStyle = 'black';
  context.fillRect(0, 0, canvas.width, canvas.height);

  // Draw the text
  context.font = '48px sans-serif';
  context.fillStyle = 'white';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.fillText(text, canvas.width / 2, canvas.height / 2);

  const texture = new THREE.CanvasTexture(canvas);
  return texture;
}


function createTextLabel(text) {
  const textTexture = createTextTexture(text);
  const geometry = new THREE.PlaneGeometry(1, 1);
  const material = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
  const textLabel = new THREE.Mesh(geometry, material);

  return textLabel;

}

<!-- SECTION: sound -->

// locking cubes 0-127 to MIDI note numbers
// The range of MIDI note numbers spans from 0 to 127, providing a total of 128 unique note numbers. This range covers a little over 10 octaves, with each octave containing 12 notes (including sharps and flats).
// The lowest MIDI note number, 0, corresponds to C-1 (C minus one), while the highest, 127, corresponds to G9. Middle C (C4) has a MIDI note number of 60. The MIDI note numbers are used to represent pitches and trigger sounds on MIDI-compatible devices and software synthesizers.

// Cube 63 currently assigned to MinkowskiSound





function highlightCube(cubeIndex, color) {
  // Get the cube from the grid using cubeUUID
  // console.log(cubeIndex +  " " + frequency);

  console.log(cubeIndex +  " " + color);
  const cube = allCubes[cubeIndex];

  // Define frequency ranges for better control
  const minFrequency = 20;
  const maxFrequency = 20000;

  // Map the frequency to lightness in HSL color space (0% to 100%)
  const lightness = 100 - (((frequency - minFrequency) / (maxFrequency - minFrequency)) * 100);

  // Generate a random rainbow hue (0 to 360 degrees)
  const hue = Math.random() * 360;

  // Convert the hue and lightness to a CSS HSL color string
  // const color = `hsl(${hue}, 100%, ${lightness}%)`;

  // Set the cube's material color to the generated color
  cube.material.color.set(color);
}




// Load the MIDI file
// const midiFileUrl = 'beethoven_op131_allegro_001_piano.mid';

// Create a new player
// const player = new Player();

// // Load the MIDI file into the player
// player.loadFile(midiFileUrl);

// // Set up an event listener for MIDI events
// player.on('midiEvent', (event) => {
//   // Look for 'Note on' events with a non-zero velocity
//   if (event.name === 'Note on' && event.velocity > 0) {
//     const note = event.noteNumber;

//     // Use the note value to determine which cube to highlight or visit
//     const cubeIndex = note % (gridSize * gridSize * gridSize); // Assuming a 9x9x9 grid of cubes
//     // const cube = cubes[cubeIndex];

//     // Highlight the cube or start a journey to the cube
//     // You can use your existing functions or create new ones to handle this
//   }
// });

// // Start playing the MIDI file
// player.play();

/*

For the sake of the thought experiment, let's consider a single wave propagating through a hypothetical medium in Minkowski spacetime. In a typical 3D space, the wave equation for sound is given by:

∇²p - (1/c²)∂²p/∂t² = 0

where ∇² is the Laplacian operator, p is the pressure disturbance in the medium, c is the speed of sound in the medium, and t is time.

To adapt this to Minkowski spacetime, we will treat the wave as a scalar field ψ in a four-dimensional spacetime with coordinates (t, x, y, z). The Minkowski metric is given by:

η = diag(-1, 1, 1, 1)

The wave equation in Minkowski spacetime for a scalar field becomes:

□ψ = 0

where □ is the d'Alembertian operator, defined as:

□ = η^(μν) ∂_μ ∂_ν

Here, η^(μν) are the components of the inverse Minkowski metric, and ∂_μ and ∂_ν are partial derivatives with respect to the spacetime coordinates. In the Cartesian coordinates, the d'Alembertian operator can be expressed as:

□ = -∂²/∂t² + ∂²/∂x² + ∂²/∂y² + ∂²/∂z²

Now, let's assume that the speed of sound in our hypothetical medium is 'c', and the wave equation for a single wave in Minkowski spacetime is:

□ψ = (1/c²)∂²ψ/∂t² - ∂²ψ/∂x² - ∂²ψ/∂y² - ∂²ψ/∂z² = 0

Keep in mind that this is a highly speculative scenario, and the behavior of sound waves in Minkowski spacetime is not well-defined in physics. Nonetheless, this adapted wave equation represents a starting point for exploring how a single wave might propagate in a Minkowski-like spacetime. The perception and interpretation of this wave by an observer in this four-dimensional spacetime would be influenced by time dilation and length contraction effects.

The JavaScript implementation provided earlier does not directly translate into sound, as it simulates the time evolution of a scalar field in a hypothetical 1D Minkowski spacetime. The behavior of sound waves in Minkowski spacetime is not well-defined in physics, and the program serves merely as an example of how one might attempt to simulate a scalar field in a Minkowski-like spacetime.


*/

    function enterMinkowskiSound() {

// Parameters
const c = 1; // Speed of sound in the hypothetical medium
const N = 100; // Number of spatial points
const dx = 1; // Spatial step
const dt = 0.5; // Time step
const tMax = Math.floor(2 * 44100 / N); // Time steps for 7 seconds of audio

// Initialize scalar field
const psi = new Array(N).fill(0);

// Initial condition (single wave at the center)
psi[Math.floor(N / 2)] = 1;

// Initialize audio context
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// Create audio buffer
const audioBuffer = audioCtx.createBuffer(1, tMax * N, audioCtx.sampleRate);

// Time evolution
for (let t = 0; t < tMax; t++) {
  const psiNext = new Array(N).fill(0);

  for (let i = 1; i < N - 1; i++) {
    psiNext[i] = 2 * psi[i] - psi[i - 1] + (c * c * dt * dt / (dx * dx)) * (psi[i + 1] - 2 * psi[i] + psi[i - 1]);
  }

  // Update the scalar field
  for (let i = 0; i < N; i++) {
    psi[i] = psiNext[i];
  }

  // Write scalar field values to audio buffer
  const buffer = audioBuffer.getChannelData(0);
  for (let i = 0; i < N; i++) {
    buffer[t * N + i] = psi[i];
  }
}

// Play the audio buffer with volume control
const playAudioBuffer = () => {
  const source = audioCtx.createBufferSource();
  const gainNode = audioCtx.createGain();

  source.buffer = audioBuffer;
  source.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  // Set the initial gain value for a softer sound
  gainNode.gain.setValueAtTime(0.01, audioCtx.currentTime);

  // Apply an exponential ramp to the gain value for smoother volume control
  gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 2);

  source.start();
};

playAudioBuffer();
}



    const synth = new Tone.Synth().toDestination();

    // Create a journey through the cubes
    var journeyOrder = [0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70];
    var journeyIndex = 0;
    var bpm = 60;
    var journeyData = document.getElementById('terminal').value;
    // const frequencies = generateFrequencies(261.63, 100);
    const allFrequencies = generateFrequencies(allCubes.length)

    function generateFrequencies(startFrequency, numNotes) {
        const ratio = Math.pow(2, 1 / 12); // 12th root of 2
        const frequencies = [startFrequency];

        for (let i = 1; i < numNotes; i++) {
          const frequency = startFrequency * Math.pow(ratio, i);
          frequencies.push(frequency);
        }

        return frequencies;
}

    
    // Play the notes associated with the cubes in the journey
    async function playJourney(path, color) {

      const clock = new THREE.Clock();

      const timeBetweenNotes = '8n';
        
          Tone.start();
          let movementProgress = 0;
          var movementDuration = 1 / (bpm/60);

        // const sequence = new Tone.Sequence((time, index) => {
        //     currentCubeIndex = journey[index];
        //     const cube = allCubes[currentCubeIndex];
        //     const note = cube.note;
        //     synth.triggerAttackRelease(note, timeBetweenNotes, time);
        // }, journey, timeBetweenNotes);

        // const moveCamera = () => {
        //     const targetCube = allCubes[journeyOrder[journeyIndex]];
        //     // synth.triggerAttackRelease(targetCube.userData.frequency, "8n");

        //     camera.position.x += (targetCube.position.x - camera.position.x) * 0.05;
        //     camera.position.y += (targetCube.position.y - camera.position.y) * 0.05;
        //     camera.lookAt(targetCube.position);
        // };
        // journeyData = path;

        journeyOrder = path;

        // journeyData = journeyOrder.toString(); 
        // document.getElementById('terminal').value = journeyData;

        const animate = function () {
              const deltaTime = clock.getDelta();
              movementDuration = 1 / (bpm/60);
              movementProgress += deltaTime;
              if(journeyOrder && journeyOrder.length > 0 )
              {
              if (movementProgress >= movementDuration) {
                  // Move to the next cube in the journeyOrder array
                  journeyIndex = (journeyIndex + 1) % journeyOrder.length;

                  // Reset movement progress
                  movementProgress = 0;

                  // Play the note associated with the current cube
                  // const frequency = cubeFrequencies[journeyOrder[journeyIndex]];
                  // synth.triggerAttackRelease(allCubes[journeyOrder[journeyIndex]].userData.frequency, "8n");

                  // playNote(frequency);
                }



                  // Calculate interpolation factor
                  const lerpFactor = movementProgress / movementDuration;
                  const cubeIndex = parseInt(journeyOrder[journeyIndex])
                  // Move the camera to the current cube's position with an offset
                  // const targetPosition = allCubes[journeyOrder[journeyIndex]].position.clone().add(new THREE.Vector3(0,0,35));
                  const targetPosition = allCubes[cubeIndex].position.clone().add(new THREE.Vector3(0,0,35));


                  const outline = allCubes[journeyOrder[journeyIndex]].getObjectByProperty("type", "LineSegments");
                    if (outline) {
                        // console.log("red-ing " + cubeId);

                      outline.material.color.set("red");
                    }

                  // TODO: come back and replays on your local machine
                  // socket.emit("cubeVisited", allCubes[journeyOrder[journeyIndex]].uuid);
                  camera.position.lerp(targetPosition, 0.01);

                  // camera.position.lerp(targetPosition, lerpFactor);
            }
            requestAnimationFrame(animate);
              const visitDuration = 3000; // Duration of each visit in milliseconds

            // moveCamera();
            // if (journeyIndex<journeyOrder.length-1)
            //   journeyIndex++;
            // else 
            //   journeyIndex= 0;
            renderer.render(scene, camera);
        };

        animate();
        
        // Tone.Transport.start();
        // sequence.start();
    };


window.playJourney = playJourney;


<!-- SECTION: hypercube -->

            // if(!hyperCubeRendered)
            // {
            //     hyperCubeRendered = true;

            // }



 let t = 0.0;

// let scene, camera, renderer;
let geometry, material;

let edges = [];
let vertexCoords = [];
let vertexCoords2 = [];
let vertexJoins = [];

var hyperCubeRendered=false; 

                init();
                render();


function path(p1, p2, p3, p4, i) {

  let vec = new THREE.Vector3(0,0,0);

  if (i >= 0 && i < 0.25) {
    vec.x = p4.x + (p1.x - p4.x ) * i * 4;
    vec.y = p4.y + (p1.y - p4.y ) * i * 4;
    vec.z = p4.z + (p1.z - p4.z ) * i * 4;
  } else if (i >= 0.25 && i < 0.5) {
    vec.x = p1.x + (p2.x - p1.x ) * (i - 0.25) * 4;
    vec.y = p1.y + (p2.y - p1.y ) * (i - 0.25) * 4;
    vec.z = p1.z + (p2.z - p1.z ) * (i - 0.25) * 4;
  } else if (i >= 0.5 && i < 0.75) {
    vec.x = p2.x + (p3.x - p2.x ) * (i - 0.5) * 4;
    vec.y = p2.y + (p3.y - p2.y ) * (i - 0.5) * 4;
    vec.z = p2.z + (p3.z - p2.z ) * (i - 0.5) * 4;
  } else if (i >= 0.75 && i < 1.0) {
    vec.x = p3.x + (p4.x - p3.x ) * (i - 0.75) * 4;
    vec.y = p3.y + (p4.y - p3.y ) * (i - 0.75) * 4;
    vec.z = p3.z + (p4.z - p3.z ) * (i - 0.75) * 4;
  }

  return vec;
}

function init() {

  vertexCoords[0]  = new THREE.Vector3(-5,-5,-5);
  vertexCoords[1]  = new THREE.Vector3( 5,-5,-5);
  vertexCoords[2]  = new THREE.Vector3( 5, 5,-5);
  vertexCoords[3]  = new THREE.Vector3(-5, 5,-5);
  vertexCoords[4]  = new THREE.Vector3(-5,-5, 5);
  vertexCoords[5]  = new THREE.Vector3( 5,-5, 5);
  vertexCoords[6]  = new THREE.Vector3( 5, 5, 5);
  vertexCoords[7]  = new THREE.Vector3(-5, 5, 5);
  vertexCoords[8]  = new THREE.Vector3(-10,-10,-10);
  vertexCoords[9]  = new THREE.Vector3( 10,-10,-10);
  vertexCoords[10] = new THREE.Vector3( 10, 10,-10);
  vertexCoords[11] = new THREE.Vector3(-10, 10,-10);
  vertexCoords[12] = new THREE.Vector3(-10,-10, 10);
  vertexCoords[13] = new THREE.Vector3( 10,-10, 10);
  vertexCoords[14] = new THREE.Vector3( 10, 10, 10);
  vertexCoords[15] = new THREE.Vector3(-10, 10, 10);

  vertexJoins = [
    [0,1], [1,2], [2,3], [3,0],
    [0,4], [1,5], [2,6], [3,7],
    [4,5], [5,6], [6,7], [7,4],

    [0,8], [1,9], [2,10], [3,11],
    [4,12], [5,13], [6,14], [7,15],

    [8,9], [9,10], [10,11], [11,8],
    [8,12], [9,13], [10,14], [11,15],
    [12,13], [13,14], [14,15], [15,12]
  ];

  // scene = new THREE.Scene();
  // camera = new THREE.OrthographicCamera( window.innerWidth / - 4, window.innerWidth / 4, window.innerHeight / 4, window.innerHeight / - 4, 1, 1000 );
  // camera.position.set(200,-100,-300);
  // camera.lookAt(new THREE.Vector3(0,0,0));

  // renderer = new THREE.WebGLRenderer();
  // renderer.setSize(window.innerWidth / 2, window.innerHeight / 2);
  document.getElementById('hypercube').appendChild(renderer.domElement);

  for (let i = 0; i < vertexJoins.length; i++) {

    geometry = new THREE.Geometry();
    geometry.vertices.push(vertexCoords[vertexJoins[i][0]]);
    geometry.vertices.push(vertexCoords[vertexJoins[i][1]]);
    let line = new THREE.Line(geometry, new THREE.LineBasicMaterial({
      color: 0x00ff00,
      linewidth: 4
    }));
    scene.add(line);
    edges[i] = line;

  }

}

function render() {
  t = (t + 0.002) % 1;

  vertexCoords2[0]  = path(vertexCoords[8], vertexCoords[9], vertexCoords[1], vertexCoords[0], t);
  vertexCoords2[1]  = path(vertexCoords[0], vertexCoords[8], vertexCoords[9], vertexCoords[1], t);
  vertexCoords2[9]  = path(vertexCoords[1], vertexCoords[0], vertexCoords[8], vertexCoords[9], t);
  vertexCoords2[8]  = path(vertexCoords[9], vertexCoords[1], vertexCoords[0], vertexCoords[8], t);

  vertexCoords2[3]  = path(vertexCoords[11], vertexCoords[10], vertexCoords[2], vertexCoords[3], t);
  vertexCoords2[2]  = path(vertexCoords[3], vertexCoords[11], vertexCoords[10], vertexCoords[2], t);
  vertexCoords2[10]  = path(vertexCoords[2], vertexCoords[3], vertexCoords[11], vertexCoords[10], t);
  vertexCoords2[11]  = path(vertexCoords[10], vertexCoords[2], vertexCoords[3], vertexCoords[11], t);

  vertexCoords2[4]  = path(vertexCoords[12], vertexCoords[13], vertexCoords[5], vertexCoords[4], t);
  vertexCoords2[5]  = path(vertexCoords[4], vertexCoords[12], vertexCoords[13], vertexCoords[5], t);
  vertexCoords2[13]  = path(vertexCoords[5], vertexCoords[4], vertexCoords[12], vertexCoords[13], t);
  vertexCoords2[12]  = path(vertexCoords[13], vertexCoords[5], vertexCoords[4], vertexCoords[12], t);

  vertexCoords2[7]  = path(vertexCoords[15], vertexCoords[14], vertexCoords[6], vertexCoords[7], t);
  vertexCoords2[6]  = path(vertexCoords[7], vertexCoords[15], vertexCoords[14], vertexCoords[6], t);
  vertexCoords2[14]  = path(vertexCoords[6], vertexCoords[7], vertexCoords[15], vertexCoords[14], t);
  vertexCoords2[15]  = path(vertexCoords[14], vertexCoords[6], vertexCoords[7], vertexCoords[15], t);

  requestAnimationFrame(render);

  for (let i = 0; i < edges.length; i++) {

    edges[i].geometry.vertices[0] = vertexCoords2[vertexJoins[i][0]];
    edges[i].geometry.vertices[1] = vertexCoords2[vertexJoins[i][1]];
    edges[i].rotation.x = 0;
    edges[i].rotation.y = 0;
    edges[i].rotation.z = 0;
    edges[i].geometry.verticesNeedUpdate = true;
  }

  renderer.render(scene, camera);
}


<!-- image processing -->

function deepClone(object) {
  const clonedObject = object.clone();
  if (object.children) {
    for (const child of object.children) {
      clonedObject.add(deepClone(child));
    }
  }
  if (object.material) {
    clonedObject.material = object.material.clone();
  }
  if (object.geometry) {
    clonedObject.geometry = object.geometry.clone();
  }
  return clonedObject;
}

//NOTE/TODO: This works but also doesn't work in that it doesn't reconstruct the child objects.
async function takeSnapshot(cube) {




  // Create a new scene for the snapshot
  const snapshotScene = new THREE.Scene();

  // Clone the cube to avoid affecting the original cube
  const clonedCube = deepClone(cube);
  snapshotScene.add(clonedCube);


  // Set the position of the cloned cube
  clonedCube.position.set(0, 0, 0);

  // Create a new camera for the snapshot
  const snapshotCamera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  snapshotCamera.position.z = 5;

  // Set the renderer size to the desired image size
  renderer.setSize(256, 256);

  // Render the snapshot scene with the snapshot camera
  renderer.render(snapshotScene, snapshotCamera);



  // Get the snapshot as a data URL
  const imageDataUrl = renderer.domElement.toDataURL('image/png');

  // Fetch the image data as a Blob
  const response = await fetch(imageDataUrl);
  const blob = await response.blob();

  // Save the snapshot as an image file using FileSaver
  saveAs(blob, 'snapshot.png');

   renderer.setSize(window.innerWidth, window.innerHeight);

}



function noteToMidi(note) {
  console.log(note);
  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const octave = parseInt(note.slice(-1));
  const noteName = note.slice(0, -1);
  const noteIndex = noteNames.indexOf(noteName);

  return noteIndex + 12 * (octave + 1);
}


function playMelody(melody) {

    console.log(melody);
    

    if(melody==null || melody.length < 2)
          melody = [
            { note: 'E4', duration: '4n' },
            { note: 'B4', duration: '4n' },
            { note: 'D5', duration: '4n' },
            { note: 'C5', duration: '4n' },
            { note: 'B4', duration: '4n' },
            { note: 'A4', duration: '4n' },
            { note: 'G4', duration: '4n' },
            { note: 'F#4', duration: '4n' },
          ];

    const synth = new Tone.PolySynth(Tone.Synth).toDestination();

    // Define the notes and durations for the first few measures of Chopin's Prelude in E minor

    const bass = [
      { note: 'E2', duration: '1m' },
      { note: 'G2', duration: '1m' },
    ];

    journeyOrder = [];

    // Schedule the notes to be played
    let time = 0;
    melody.forEach(({ note, duration }) => {
      // console.log(self);
      // if(self instanceof String) {
        
      //   note = self;
      //   duration = '4n';
      // }

      // if (!duration || duration.length < 2)
      //   duration = '4n';

      journeyOrder.push(noteToMidi(note));
      synth.triggerAttackRelease(note, duration, time);
      time += Tone.Time(duration).toSeconds();
    });

   console.log(journeyOrder);    

    bass.forEach(({ note, duration }, index) => {
      synth.triggerAttackRelease(note, duration, Tone.Time(duration).toSeconds() * index);
    });

    // Start playing the music
    Tone.Transport.start();
    playJourney(journeyOrder);


}
<!-- SECTION: CREDITS --> 




// async function getUserBalance(activeUser, (err, balance) => {
//   if (err) {
//     console.error('Error fetching balance:', err);
//   } else if (balance !== null) {
//     console.log('Balance fetched:', balance);
//   } else {
//     console.log('User not found.');
//   }
// });



// getUserBalance(userId) {
//   const response = await fetch(`/api/users/${userId}/balance`);
//   const data = await response.json();

//   return data.balance;
// }

function updateBalanceDisplay(balance) {
  const balanceElement = document.getElementById("balance");
  balanceElement.textContent = `Space Money: ${balance}`;
}

async function onUserLogin(userId) {
  const balance = await getUserBalance(userId);
  updateBalanceDisplay(balance);
}

<!-- SECTION: 3DCONWAY --> 


function createInitial3DGrid(size) {
  const cubeGrid = seedGameOfLife(size);
  const cubeObjects = [];

  for (let x = 0; x < size; x++) {
    cubeObjects[x] = [];
    for (let y = 0; y < size; y++) {
      cubeObjects[x][y] = [];
      for (let z = 0; z < size; z++) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({color: 'black'});
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y, z);
        scene.add(cube);
        cubeObjects[x][y][z] = cube;
      }
    }
  }

  // Update the cube materials based on the initial Game of Life grid state
  updateCubeMaterials(cubeGrid, cubeObjects);

  return { cubeGrid, cubeObjects };
}

function updateCubeMaterials(cubeGrid, cubeObjects) {
  for (let x = 0; x < cubeGrid.length; x++) {
    for (let y = 0; y < cubeGrid[0].length; y++) {
      for (let z = 0; z < cubeGrid[0][0].length; z++) {
        const alive = cubeGrid[x][y][z] === 1;
        const cube = cubeObjects[x][y][z];
        cube.material.color.set(alive ? 'white' : 'black'); // Set the color based on the cell state
      }
    }
  }
}
      // goToCube({ x: 1, y: 1, z: 1 }, 1, 0.5, 1000);

// Usage:
// Assuming you have a 3D array called `cubeObjects` containing your Three.js cubes
// and `cubeGrid` is the 3D grid state from the `seedGameOfLife` function
// updateCubeMaterials(cubeGrid, cubeObjects);

// const cubeSize = 8; // Adjust the size of the 3D grid as needed

// for (const uuid in cubes) {
//   const cube = cubes[uuid];
//   const initialGrid = createInitial3DGrid(cubeSize);
//   animate3DGameOfLife(cube, initialGrid);
// }

function animate3DGameOfLife(cube, grid) {
  grid = getNextState(grid);
  console.log(grid);
  cube.remove(...cube.children); // Remove previous cells
  visualize3DGrid(grid, cube);
  setTimeout(() => animate3DGameOfLife(cube, grid), 500); // Set the delay between updates
}

function visualize3DGrid(grid, cube) {
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const material = new THREE.MeshBasicMaterial({ color: 0xffffff });

  for (let x = 0; x < grid.length; x++) {
    for (let y = 0; y < grid[x].length; y++) {
      for (let z = 0; z < grid[x][y].length; z++) {
        if (grid[x][y][z] === 1) {
          const cell = new THREE.Mesh(geometry, material);
          cell.position.set(x, y, z);
          cube.add(cell);
        }
      }
    }
  }
}

function getNextState(grid) {
  const nextGrid = JSON.parse(JSON.stringify(grid));
  for (let x = 0; x < grid.length; x++) {
    for (let y = 0; y < grid[x].length; y++) {
      for (let z = 0; z < grid[x][y].length; z++) {
        const neighborsCount = getNeighborsCount(x, y, z, grid);

        if (grid[x][y][z] === 1) {
          // Cell is alive
          if (neighborsCount < 2 || neighborsCount > 3) {
            // Underpopulation or overpopulation
            nextGrid[x][y][z] = 0;
          }
        } else {
          // Cell is dead
          if (neighborsCount === 3) {
            // Reproduction
            nextGrid[x][y][z] = 1;
          }
        }
      }
    }
  }
  return nextGrid;
}

function getNeighborsCount(x, y, z, grid) {
  let count = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      for (let k = -1; k <= 1; k++) {
        if (i === 0 && j === 0 && k === 0) continue; // Ignore the current cell
        const xi = (x + i + grid.length) % grid.length;
        const yj = (y + j + grid[0].length) % grid[0].length;
        const zk = (z + k + grid[0][0].length) % grid[0][0].length;
        count += grid[xi][yj][zk] === 1 ? 1 : 0;
      }
    }
  }
  return count;
}

function testGridStateMatch(cubeGrid, cubeObjects) {
  for (let x = 0; x < cubeGrid.length; x++) {
    for (let y = 0; y < cubeGrid[x].length; y++) {
      for (let z = 0; z < cubeGrid[x][y].length; z++) {
        const cubeAlive = cubeGrid[x][y][z] === 1;
        const cubeColor = cubeObjects[x][y][z].material.color;
        const expectedColor = cubeAlive ? new THREE.Color('white') : new THREE.Color('black');
        
        if (!cubeColor.equals(expectedColor)) {
          console.error(`Mismatch at (${x}, ${y}, ${z}): expected ${expectedColor.getHexString()}, got ${cubeColor.getHexString()}`);
          return false;
        }
      }
    }
  }

  console.log('Test passed: 3D grid state matches Game of Life grid state.');
  return true;
}


function seedGameOfLife(cubeGrid, probability) {
  for (let x = 0; x < cubeGrid.length; x++) {
    for (let y = 0; y < cubeGrid[0].length; y++) {
      for (let z = 0; z < cubeGrid[0][0].length; z++) {
        cubeGrid[x][y][z] = Math.random() < probability ? 1 : 0;
      }
    }
  }
}

// Example usage:
const gridSize = 9;
const cubeGrid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0)));
const initialProbability = 0.3; // Adjust the probability of a cell being alive (0 to 1)
// seedGameOfLife(cubeGr  id, initialProbability);
const globeRadius = 15;
// animate3DGameOfLife(allCubes[1], createInitial3DGrid(8));
createEarth();

<!-- SECTION: NETWORKSTATE --> 

class ArcCurve extends THREE.Curve {
  constructor(start, end, height) {
    super();
    this.start = start;
    this.end = end;
    this.height = height;
  }

  getPoint(t) {
    const x = this.start.x + t * (this.end.x - this.start.x);
    const y = this.start.y + t * (this.end.y - this.start.y);
    const z = this.start.z + t * (this.end.z - this.start.z);
    const arcHeight = (1 - 2 * t) * this.height;

    return new THREE.Vector3(x, y + arcHeight, z);
  }
}

var zuzaluMarker;

function createEarth() {

    // Create Earth sphere
    const earthGeometry = new THREE.SphereGeometry(globeRadius, globeRadius, globeRadius);
    const earthTexture = new THREE.TextureLoader().load('/img/world.topo.bathy.200412.3x5400x2700.jpg');
    const earthMaterial = new THREE.MeshBasicMaterial({ map: earthTexture });
    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    allCubes[123].add(earth);
    // Add a prospera marker off the coast of Honduras
    const prosperaLat = 16.5;
    const prosperaLon = -86.5;
    const prosperaRadius = globeRadius + 0.5;
    const prosperaCoords = { lat: 16.5, lon: -86.5 };
    const prosperaColor =  0xff0000;
    const prosperaMaterial = new THREE.MeshBasicMaterial({ color: prosperaColor });
    const prosperaPosition = latLongToVector3(prosperaLat, prosperaLon, prosperaRadius);
    const prosperaGeometry = new THREE.SphereGeometry(.2, 32, 32);
    const prosperaMarker = new THREE.Mesh(prosperaGeometry, prosperaMaterial);
    prosperaMarker.position.copy(prosperaPosition);
    earth.add(prosperaMarker);
    

    const catawbaLat = 35.5849;
    const catawbaLon = -81.2078;
    const catawbaCoords = { lat: 35.5849, lon: -81.2078 };
    const catwabaColor =  0xff00ff;
    const catwabaMaterial = new THREE.MeshBasicMaterial({ color: catwabaColor });
    const catawbaMarker = new THREE.Mesh(prosperaGeometry, catwabaMaterial);
    const catawbaMarkerPosition = latLongToVector3(catawbaLat, catawbaLon, prosperaRadius);
    catawbaMarker.position.copy(catawbaMarkerPosition);
    earth.add(catawbaMarker);

    // Luštica Bay, Montenegro

    const zuzalu = new THREE.Mesh(prosperaGeometry, prosperaMaterial);
    const zuzaluColor =  0xffffff;
    const zuzaluCoords = { lat: 42.3919, lon: 18.6506 };
    const zuzaluMarkerPosition = latLongToVector3(zuzaluCoords.lat, zuzaluCoords.lon, prosperaRadius);
    const zuzaluMaterial = new THREE.MeshBasicMaterial({ color:zuzaluColor });
    zuzaluMarker = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), zuzaluMaterial);

    zuzaluMarker.position.copy(zuzaluMarkerPosition);
    earth.add(zuzaluMarker);
    clickableObjects.push(zuzaluMarker);


    // Parq Ubud, Bali
    const ubudCoords = { lat: -8.5069, lon: 115.2625 };
    const ubudColor =  0xee00ee;
    const ubudMarkerPosition = latLongToVector3(ubudCoords.lat, ubudCoords.lon, prosperaRadius);
    const ubudMaterial = new THREE.MeshBasicMaterial({ color:zuzaluColor });
    const ubudMarker = new THREE.Mesh(prosperaGeometry, prosperaMaterial);
    ubudMarker.position.copy(ubudMarkerPosition);
    earth.add(ubudMarker);


    const zanzibarCoords = { lat: -6.1652, lon: 39.1989 };
    const zanzibarColor =  0x00ee00;
    const zanzibarMarkerPosition = latLongToVector3(zanzibarCoords.lat, zanzibarCoords.lon, prosperaRadius);
    const zanzibarMaterial = new THREE.MeshBasicMaterial({ color:zanzibarColor });
    const zanzibarMarker = new THREE.Mesh(prosperaGeometry, zanzibarMaterial);
    zanzibarMarker.position.copy(zanzibarMarkerPosition);
    earth.add(zanzibarMarker);




// Create animated arcs from other locations to Luštica Bay


const hondurasTozuzaluArc = createAnimatedArc(prosperaCoords, zuzaluCoords, prosperaColor, earth);
const catawbaTozuzaluArc = createAnimatedArc(catawbaCoords, zuzaluCoords, catwabaColor, earth);
const ubudTozuzaluArc = createAnimatedArc(ubudCoords, zuzaluCoords, ubudColor, earth) ;
const zanzibarTozuzaluArc = createAnimatedArc(zanzibarCoords, zuzaluCoords, zanzibarColor, earth) ;


// TODO: fix, fails on error  "Uncaught TypeError: arc.getPointAt is not a function"
 
// const hondurasTozuzaluArc = createArc(hondurasMarker.position, zuzaluMarker.position, 0xff0000);
// const catawbaTozuzaluArc = createArc(catawbaMarker.position, zuzaluMarker.position, 0xff00ff);
// const ubudTozuzaluArc = createArc(ubudMarker.position, zuzaluMarker.position, 0xffff00);
console.log(hondurasTozuzaluArc);

// createMovingSphere(hondurasTozuzaluArc, 0xff0000);
// createMovingSphere(catawbaTozuzaluArc, 0xff00ff);
// createMovingSphere(ubudTozuzaluArc, 0xffff00);
// createMovingSphere(zanzibarTozuzaluArc, 0xffff00);

    // Set camera position and animate
    // camera.position.z = 3;

    const animate = function () {
      requestAnimationFrame(animate);

      earth.rotation.y += 0.005;

      renderer.render(scene, camera);
    };

    animate();


}

function latLongToVector3(lat, lon, radius) {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);

  return new THREE.Vector3(
    -radius * Math.sin(phi) * Math.cos(theta),
    radius * Math.cos(phi),
    radius * Math.sin(phi) * Math.sin(theta)
  );
}

function createArc(start, end, color) {
  const midPoint = new THREE.Vector3(
    (start.x + end.x) / 2,
    (start.y + end.y) / 2 + 0.3,
    (start.z + end.z) / 2
  );

  const arcCurve = new THREE.CatmullRomCurve3([start, midPoint, end], false, 'catmullrom', 0.5);
  const arcPoints = arcCurve.getPoints(50);
  const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
  const arcMaterial = new THREE.LineBasicMaterial({ color: color });
  const arc = new THREE.Line(arcGeometry, arcMaterial);
  scene.add(arc);
  return arcCurve;
}


// function createArc(start, end, color) {
//   const arcCurve = new ArcCurve(start, end, 0.3);
//   const arcPoints = arcCurve.getPoints(50);
//   const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
//   const arcMaterial = new THREE.LineBasicMaterial({ color: color });
//   const arc = new THREE.Line(arcGeometry, arcMaterial);
//   scene.add(arc);
//   return arcCurve;
// }


function createAnimatedArc(startCoords, endCoords, color, earth) {
  const arc = new THREE.CatmullRomCurve3([
    latLongToVector3(startCoords.lat, startCoords.lon, globeRadius + .8),
    latLongToVector3(
      (startCoords.lat + endCoords.lat) / 2,
      (startCoords.lon + endCoords.lon) / 2,
      globeRadius + 1
    ),
    latLongToVector3(endCoords.lat, endCoords.lon, globeRadius + .8),
  ]);

  const points = arc.getPoints(50);
  const geometry = new THREE.BufferGeometry().setFromPoints(points);

  const material = new THREE.LineBasicMaterial({ color: color });
  const line = new THREE.Line(geometry, material);

  earth.add(line);

  return arc;
}


function onCanvasClick(event) {
  event.preventDefault();

  // Calculate mouse position in normalized device coordinates
  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // Update the picking ray with the camera and mouse position
  raycaster.setFromCamera(mouse, camera);

  // Calculate objects intersecting the picking ray
  const intersects = raycaster.intersectObjects(clickableObjects);

  // Check if Lustica Bay marker was clicked and open the URL in a new tab
  if (intersects.length > 0 && intersects[0].object === zuzaluMarker) {
    console.log("zuzalu clicked");
    window.open("https://app.tryspace.com/T9Dh6wP/desert", "_blank");
  }
}



function createMovingSphere(arc, radius, color, speed = 0.01) {
  const sphereGeometry = new THREE.SphereGeometry(radius, 32, 32);
  const sphereMaterial = new THREE.MeshBasicMaterial({ color: color });
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  
  const curve = new THREE.CatmullRomCurve3(arc);
  let t = 0;

  // Your animation loop
  function animate() {
    requestAnimationFrame(animate);

    // Update the position of the sphere along the curve
    t += speed;
    if (t >= 1) t = 0;

    const position = arc.getPoint(t);
    sphere.position.copy(position);

    renderer.render(scene, camera);
  }

  animate();

  return sphere;
}


<!-- SECTION: MARS --> 

function createMarker(latitude, longitude, color, planet) {
  const markerGeometry = new THREE.SphereGeometry(0.005, 32, 32);
  const markerMaterial = new THREE.MeshBasicMaterial({ color: color });
  const marker = new THREE.Mesh(markerGeometry, markerMaterial);

  const phi = (90 - latitude) * (Math.PI / 180);
  const theta = (longitude + 180) * (Math.PI / 180);
  const radius = (planet === 'mars') ? 1.01 : 1.01;

  marker.position.x = -radius * Math.sin(phi) * Math.cos(theta);
  marker.position.y = radius * Math.cos(phi);
  marker.position.z = radius * Math.sin(phi) * Math.sin(theta);

  return marker;
}

function createMars() {

      // Create Mars
      const marsRadius = 10.88;
      const marsGeometry = new THREE.SphereGeometry(marsRadius, 32, 32);
      const marsTexture = new THREE.TextureLoader().load('img/2k_mars.jpeg'); // Use an appropriate Mars texture
      const marsMaterial = new THREE.MeshBasicMaterial({ map: marsTexture });
      const mars = new THREE.Mesh(marsGeometry, marsMaterial);
      allCubes[124].add(mars);

      // Add markers for Mars settlements
      const marsSettlement1 = createMarker(12.74, 77.59, marsRadius, 0xff0000);
      const marsSettlement2 = createMarker(-23.7, 133.88, marsRadius, 0x00ff00);

      // Create an arc between settlements
      const marsArc = createArc(marsSettlement1.position, marsSettlement2.position, 0xffff00);

      // Animate a sphere moving along the arc
      const marsMovingSphere = createMovingSphere(marsArc, 0.005, 0.02, 0x0000ff);

      // Set camera position
      // camera.position.z = 5;

      // Animate the scene
      function animate() {
        requestAnimationFrame(animate);
        mars.rotation.y += 0.001;
        // marsMovingSphere.position.copy(marsArc.getPointAt(marsMovingSphere.userData.t));
        // marsMovingSphere.userData.t += marsMovingSphere.userData.speed;
        // if (marsMovingSphere.userData.t > 1) marsMovingSphere.userData.t = 0;
        renderer.render(scene, camera);
      }
      animate();

}


function tradeRoute() {

  // Create the cube
  const cubeGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
  const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  scene.add(cube);

  console.log(allCubes[63]);
  // Position of Earth and Mars
  const earthPosition = new THREE.Vector3(allCubes[63].position.x, allCubes[63].position.y, allCubes[63].position.z);
  const marsPosition = new THREE.Vector3(allCubes[88].position.x, allCubes[88].position.y, allCubes[88].position.z); // Adjust the position of Mars as needed
  console.log(earthPosition);
  console.log(marsPosition);

  // Animation
  let t = 0;
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    // console.log(t);
    // Update the cube position
    t += 0.001;
    if (t > 1) {
      t = 0;
    }
    cube.position.lerpVectors(earthPosition, marsPosition, t);
  }
  animate();


}
createMars();
tradeRoute();

<!-- SECTION: ASCIIART --> 

async function loadTextFromFile(url) {
  console.log("loading file");

  const response = await fetch(url);
  const text = await response.text();
  return text;

}

async function createTexturedCube(textUrl, width, height) {
  beethovenText = await fetch(textUrl).then(response => response.text());
  const textCanvas = createTextCanvas(beethovenText, colors);
  const texture = new THREE.CanvasTexture(textCanvas);

  const geometry = new THREE.BoxGeometry(10, 10, 10);
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.9
  });

  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  const edges = new THREE.EdgesGeometry(geometry);
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  const wireframe = new THREE.LineSegments(edges, lineMaterial);

  cube.add(wireframe);
  return cube;
}

const colors = [
    'red',
    'orange',
    'yellow',
    'green',
    'blue',
    'indigo',
    'violet',
  ];


function createTextCanvas(text, colors) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const lines = text.split('\n');

  const fontSize = 12; // Adjust this value as needed
  // ctx.fillStyle = 'white';
  ctx.font = `${fontSize}px monospace`;
  ctx.textBaseline = 'top';

  // Calculate the width and height of the canvas based on the text dimensions
  const maxWidth = Math.max(...lines.map((line) => ctx.measureText(line).width));
  const totalHeight = fontSize * lines.length;

  // Set the canvas width and height
  canvas.width = maxWidth;
  canvas.height = totalHeight;

  // Draw each line of the text with the corresponding color
  lines.forEach((line, index) => {
    ctx.fillStyle = colors[index % colors.length];
    ctx.fillText(line, 0, fontSize * index);
  });

  return canvas;
}

// function createTextCanvas(text, width, height, fontSize = 5) {




//   const canvas = document.createElement('canvas');
//   canvas.width = width;
//   canvas.height = height;
//   const ctx = canvas.getContext('2d');
//   ctx.fillStyle = 'white';
//   ctx.fillRect(0, 0, width, height);
//   ctx.font = `${fontSize}px monospace`;
//   ctx.fillStyle = 'black';
//   const lines = text.split('\n');
//   const lineHeight = fontSize + 2;
//   let yPos = fontSize;
//   // for (const line of lines) {
//   //   ctx.fillStyle = colors[i % colors.length];
//   //   ctx.fillText(line, 0, yPos);
//   //   yPos += lineHeight;
//   // }

//   for (let i = 0; i < lines.length; i++) {
//     const line = lines[i];
//     ctx.fillStyle = colors[i % colors.length];
//     ctx.fillText(line, 0, yPos);
//     // context.fillText(line, 0, i * size);
//     yPos += lineHeight;

//   }


  // for (let i = 0; i < lines.length; i++) {
  //   const line = lines[i];
  //   context.fillStyle = colors[i % colors.length];
  //   context.fillText(line, 0, i * size);
  // }

//   return canvas;
// }

// TODO: fix. Another GPT #fail
function updateTextColor(cube, newColor) {
  const material = cube.material;
  
  for (let i = 0; i < 6; i++) {
    if (material[i] && material[i].map) {
      const texture = material[i].map;
      const canvas = texture.image;
      const ctx = canvas.getContext('2d');
      const text = textContent[i]; // Use the saved text content

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = newColor;
      ctx.font = '5px monospace';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      texture.needsUpdate = true;
    }
  }
}


const textUrl = 'beethoven.txt';
const width = 512;
const height = 512;
var beethovenCube;

async function createBeethovenCube() {
  const textUrl = 'beethoven.txt';
  const width = 512;
  const height = 512;

  beethovenCube = await createTexturedCube(textUrl, width, height);


}
createBeethovenCube();

async function changeTextCubeColor(cubePromise, newColor) {
  const cube = await cubePromise;
  updateTextColor(cube, newColor);
}

<!-- SECTION: CHEMSKI --> 

function h2o(cubeIndex, offset = 0) {


    // Create atom models
    const oxygenGeometry = new THREE.SphereGeometry(.5, 32, 32);
    const oxygenMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
    const oxygenAtom = new THREE.Mesh(oxygenGeometry, oxygenMaterial);

    const hydrogenGeometry = new THREE.SphereGeometry(0.25, 32, 32);
    const hydrogenMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    const hydrogenAtom1 = new THREE.Mesh(hydrogenGeometry, hydrogenMaterial);
    const hydrogenAtom2 = new THREE.Mesh(hydrogenGeometry, hydrogenMaterial);

    const velocityOxygen = new THREE.Vector3(0.02 + offset, 0.03 + offset, 0);
    const velocityHydrogen1 = new THREE.Vector3(0.02 + offset, 0.03 + offset, 0);
    const velocityHydrogen2 = new THREE.Vector3(0.02 + offset, 0.03 + offset, 0);


    // Position the atoms
    oxygenAtom.position.set(0, 0, 0);
    hydrogenAtom1.position.set(-1, 1, 0);
    hydrogenAtom2.position.set(1, 1, 0);

    // Add atoms to the scene
    allCubes[cubeIndex].add(oxygenAtom);
    allCubes[cubeIndex].add(hydrogenAtom1);
    allCubes[cubeIndex].add(hydrogenAtom2);

    // camera.position.z = 5;


// Set up the camera position
// camera.position.z = 5;

// Render the scene
function animate() {
  requestAnimationFrame(animate);
  oxygenAtom.position.add(velocityOxygen);
  hydrogenAtom1.position.add(velocityHydrogen1);
  hydrogenAtom2.position.add(velocityHydrogen2);

  renderer.render(scene, camera);
}
animate();


}


async function fetchMoleculeData(query) {
  const url = `https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/${query}/record/SDF/?record_type=3d&response_type=display`;
  const response = await fetch(url);
  const sdfData = await response.text();
  return sdfData;
}


async function anyMolecule(name, startingCube = 1)
{
   const sdfData = await fetchMoleculeData(name);
  const molecule = parseSDF(sdfData);
const atomColorMap = { O: 0xff0000, H: 0x00ff00 };
const atomRadiusMap = { O: 0.5, H: 0.25 };
const bondColor = 0x0000ff;
const bondRadius = 0.1;

// Create atoms and add them to the scene
molecule.atoms.forEach((atom) => {
  const sphere = createAtomSphere(atomColorMap[atom.symbol], atomRadiusMap[atom.symbol], new THREE.Vector3(atom.x, atom.y, atom.z));
  allCubes[172].add(sphere);
});

// Create bonds and add them to the scene
molecule.bonds.forEach((bond) => {
  const start = new THREE.Vector3(
    molecule.atoms[bond.atom1 - 1].x,
    molecule.atoms[bond.atom1 - 1].y,
    molecule.atoms[bond.atom1 - 1].z
  );
  const end = new THREE.Vector3(
    molecule.atoms[bond.atom2 - 1].x,
    molecule.atoms[bond.atom2 - 1].y,
    molecule.atoms[bond.atom2 - 1].z
  );
  const cylinder = createBondCylinder(bondColor, start, end, bondRadius);
  allCubes[172].add(cylinder);
});

const atomCount = molecule.atoms.length;
const moleculePosition = new THREE.Vector3(0, 0, 0);

molecule.atoms.forEach((atom) => {
  moleculePosition.add(new THREE.Vector3(atom.x, atom.y, atom.z));
});

moleculePosition.divideScalar(atomCount);
molecule.position = moleculePosition;
console.log(molecule);
// Calculate the direction vector pointing from the molecule's position to the center
const center = new THREE.Vector3(0, 0, 0);
const direction = new THREE.Vector3().subVectors(center, molecule.position);

// Normalize and scale the direction vector according to the desired speed
const speed = 0.01; // Adjust this value as needed
direction.normalize().multiplyScalar(speed);

// Your animation loop
function animate() {
  requestAnimationFrame(animate);

  // Calculate the gravitational force acting on the molecule
  const gravitationalConstant = 0.0001; // Adjust this value as needed
  const distanceToCenter = molecule.position.distanceTo(center);
  const gravitationalForce = gravitationalConstant / (distanceToCenter * distanceToCenter);

  // Calculate the direction vector pointing from the molecule's position to the center
  const direction = new THREE.Vector3().subVectors(center, molecule.position);

  // Normalize and scale the direction vector according to the gravitational force
  direction.normalize().multiplyScalar(gravitationalForce);

  // Update the position of the molecule
  molecule.position.add(direction);

  renderer.render(scene, camera);
}

animate();




}

function parseSDF(sdfData) {
  console.log(sdfData);
  const lines = sdfData.split('\n');
  const atomCount = parseInt(lines[3].slice(0, 3).trim(), 10);
  const bondCount = parseInt(lines[3].slice(3, 6).trim(), 10);

  const atoms = [];
  for (let i = 4; i < 4 + atomCount; i++) {
    const line = lines[i];
    const x = parseFloat(line.slice(0, 10).trim());
    const y = parseFloat(line.slice(10, 20).trim());
    const z = parseFloat(line.slice(20, 30).trim());
    const symbol = line.slice(31, 34).trim();
    atoms.push({ symbol, x, y, z });
  }

  const bonds = [];
  for (let i = 4 + atomCount; i < 4 + atomCount + bondCount; i++) {
    const line = lines[i];
    const atom1 = parseInt(line.slice(0, 3).trim(), 10);
    const atom2 = parseInt(line.slice(3, 6).trim(), 10);
    const bondType = parseInt(line.slice(6, 9).trim(), 10);
    bonds.push({ atom1, atom2, bondType });
  }

  return { atoms, bonds };
}


// Helper function to create spheres for atoms
function createAtomSphere(color, radius, position) {
  const geometry = new THREE.SphereGeometry(radius, 32, 32);
  const material = new THREE.MeshPhongMaterial({ color });
  const sphere = new THREE.Mesh(geometry, material);
  sphere.position.set(position.x, position.y, position.z);
  return sphere;
}

// Helper function to create cylinders for bonds
function createBondCylinder(color, start, end, radius) {
  const direction = new THREE.Vector3().subVectors(end, start);
  const length = direction.length();
  const geometry = new THREE.CylinderGeometry(radius, radius, length, 32);
  const material = new THREE.MeshPhongMaterial({ color });
  const cylinder = new THREE.Mesh(geometry, material);

  cylinder.position.copy(start).addScaledVector(direction, 0.5);
  cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
  return cylinder;
}

// Add lighting to the scene
// const light = new THREE.PointLight(0xffffff, 1, 1000);
// light.position.set(50, 50, 50);
// scene.add(light);

// Assuming you have parsed the SDF data and have the atoms and bonds information

// var whichP = location.hash;
// whichP = whichP.replace(/#/g, "");
// if (whichP != "") {
// document.getElementById("listofmols").value = whichP;
// } else {
// document.getElementById("listofmols").value = "SKInote";
// }
// whichButtons("SKInote"); 
// selectionLambda();


  // TODO: fix, document comes up with near empy gtml file
//   var maxNumberOfNodesStr = document.getElementById("maxnodenumber").innerHTML;
//   var maxNumberOfNodes = maxNumberOfNodesStr - 2;
//  var numberOfCenterNodes = Math.floor(nodes.length / 4);
//  document.getElementById("nodenumber").innerHTML = numberOfCenterNodes;
       
        
//   var rewriteWeight = (document.getElementById("rewritesRange").value) / 100;
          


// const { cubeGrid, cubeObjects } = createInitial3DGrid(3);
// testGridStateMatch(cubeGrid, cubeObjects);
renderer.domElement.addEventListener("click", onCanvasClick, false);

<!-- SECTION: analyzeFrequencyAndHighlightCubes -->
async function updateColors() {
  analyser.getByteFrequencyData(dataArray);

  // Determine the average value of the high-frequency bands
  const highFreqStart = Math.floor(bufferLength * 0.7);
  const highFreqEnd = bufferLength;
  let highFreqSum = 0;
  
  for (let i = highFreqStart; i < highFreqEnd; i++) {
    highFreqSum += dataArray[i];
  }
  console.log("hf+" + highFreqSum);

  const highFreqAvg = highFreqSum / (highFreqEnd - highFreqStart);

  console.log("ha+" + highFreqAvg);

  // Define the colors based on the high-frequency bands
  const baseColors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
  const newColors = baseColors.map((color) => {
    const hsl = new THREE.Color(color).getHSL({});
    const lightness = Math.min(1, hsl.l + ((highFreqSum / 255) ));
    highlightCube(highFreqSum+20, hsl);
    return new THREE.Color().setHSL(hsl.h, hsl.s, lightness).getStyle();
    // return new THREE.Color().setHSL(240, 240, 244).getStyle();

  });


  // beethovenText = "boo";
  // Update the ASCII art with the new colors
  const textCanvas = createTextCanvas(beethovenText, newColors);
  const texture = new THREE.CanvasTexture(textCanvas);
  console.log(beethovenCube);
  beethovenCube.material.map = texture;
  beethovenCube.material.needsUpdate = true;
}

function analyzeFrequencyAndHighlightCubes() {
  console.log("analyzeFrequencyAndHighlightCubes");

  // Create an array to store the frequency data
  const frequencyData = new Uint8Array(analyser.frequencyBinCount);
  
  console.log(frequencyData);

  // Get the frequency data from the analyser
  analyser.getByteFrequencyData(frequencyData);

  // Process the frequency data and highlight the cubes
  for (let i = 0; i < frequencyData.length; i++) {
    // Normalize the frequency value (0 to 1)
    const normalizedFrequency = frequencyData[i] / 256;
    console.log("nf" + normalizedFrequency);
    // Determine the index of the cube to highlight based on the normalized frequency
    const cubeIndex = Math.floor(normalizedFrequency * (5*5*5));
    // Highlight the cube with the index cubeIndex
    highlightCube(cubeIndex, frequencyData[i]);
  }

  // Call this function again using requestAnimationFrame
  requestAnimationFrame(analyzeFrequencyAndHighlightCubes);
}

<!-- section: maze -->


function createMaze(width, height) {
  const maze = new Array(height).fill(null).map(() => new Array(width).fill(false));
  const stack = [];
  const directions = [
    [0, 1],
    [1, 0],
    [0, -1],
    [-1, 0]
  ];

  function inBounds(x, y) {
    return x >= 0 && x < width && y >= 0 && y < height;
  }

  function carve(x, y) {
    maze[y][x] = true;
    const shuffledDirections = directions.sort(() => Math.random() - 0.5);

    for (const [dx, dy] of shuffledDirections) {
      const nx = x + dx * 2;
      const ny = y + dy * 2;

      if (inBounds(nx, ny) && !maze[ny][nx]) {
        maze[y + dy][x + dx] = true;
        carve(nx, ny);
      }
    }
  }

  carve(1, 1);
  return maze;
}

//TODO: latest GPT version crashes 
function maze()
{
  makeMeAMaze(allCubes[selectedCubeIndex])

}
// maze.helpText = "make a maze inside the currently selected cube"

function makeMeAMaze(parent) {
  console.log('maze');
  console.log(parent);

  const mazeWidth = 21;
  const mazeHeight = 21;
  const maze = createMaze(mazeWidth, mazeHeight);

  const blockSize = 1;

  for (let y = 0; y < mazeHeight; y++) {
    for (let x = 0; x < mazeWidth; x++) {
      if (!maze[y][x]) {
        const cubeGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0x1e90ff });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(parent.xPos + x * blockSize, parent.yPos + blockSize / 2, parent.zPos + y * blockSize);
        scene.add(cube);
      }
    }
  }

  // Find the entrance position
  const entranceX = parent.xPos + blockSize * (maze.start.x + 0.5);
  const entranceY = parent.yPos + blockSize / 2;
  const entranceZ = parent.zPos + blockSize * (maze.start.y + 0.5);
  const entrance = new THREE.Vector3(entranceX, entranceY, entranceZ);

  // Position the camera at the entrance
  camera.position.set(entrance.x, entrance.y + 10, entrance.z - 15);
  camera.lookAt(entrance);

  // Add a slight rotation to primarily see the entrance
  camera.rotation.y = 0.3;
}





class ExtendedOrbitControls extends THREE.OrbitControls {
  constructor(camera, domElement) {
    super(camera, domElement);

    this.moveSpeed = 0.1;
    this.moveUp = false;
    this.moveDown = false;

    const onKeyDown = (event) => {
      switch (event.code) {
        case 'KeyQ':
          this.moveUp = true;
          break;
        case 'KeyE':
          this.moveDown = true;
          break;
      }
    };

    const onKeyUp = (event) => {
      switch (event.code) {
        case 'KeyQ':
          this.moveUp = false;
          break;
        case 'KeyE':
          this.moveDown = false;
          break;
      }
    };

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
  }

  update() {
    if (this.moveUp) {
      this.object.position.y += this.moveSpeed;
    }
    if (this.moveDown) {
      this.object.position.y -= this.moveSpeed;
    }
    super.update();
  }
}

<!-- SECTION: Garbage collection -->

function countObjects(scene) {
  let objectCount = 0;

  function countChildren(object) {
    objectCount++;

    if (object.children.length > 0) {
      object.children.forEach(child => {
        countChildren(child);
      });
    }
  }

  scene.children.forEach(child => {
    countChildren(child);
  });

  return objectCount;
}

// Function to compare objects based on their distance from the center
function compareByDistance(a, b) {
  const center = new THREE.Vector3(0, 0, 0);
  const distanceA = a.position.distanceTo(center);
  const distanceB = b.position.distanceTo(center);
  return distanceB - distanceA;
}

// Garbage collector function
function garbageCollector(scene, percentage = 0.1) {
  const allObjects = [];

  scene.traverse((object) => {
    if (object instanceof THREE.Mesh) {
      allObjects.push(object);
    }
  });

  // Sort the objects by distance from the center
  allObjects.sort(compareByDistance);

  // Calculate the number of objects to remove (10%)
  const numToRemove = Math.ceil(allObjects.length * percentage);

  // Remove the farthest 10% of objects
  for (let i = 0; i < numToRemove; i++) {
    const object = allObjects[i];
    object.geometry.dispose();
    object.material.dispose();
    scene.remove(object);
  }
}

// Periodically call the garbage collector
// setInterval(() => {
//   garbageCollector(scene);
// }, 10000); // Run garbage collector every 10 seconds

<!-- SECTION: advanced navigation -->

// TODO: don't love this
function goto(cubeIndex, approachDistance = 8, sideAngle = Math.PI / 4) {
  const targetPosition = allCubes[cubeIndex].position.clone();
  const approachVector = new THREE.Vector3(0, 0, approachDistance);
  
  // Rotate the approach vector by the specified side angle around the Y axis
  approachVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), sideAngle);
  
  // Move the camera to the target position plus the approach vector
  const cameraTarget = targetPosition.add(approachVector);
  
  // Animate the movement over time using the lerp function
  const lerpFactor = 0.1;
  const animateCamera = () => {
    camera.position.lerp(cameraTarget, lerpFactor);
    camera.lookAt(targetPosition);
    
    if (camera.position.distanceTo(cameraTarget) > 0.1) {
      requestAnimationFrame(animateCamera);
    }
  };
  
  animateCamera();
}
goto.helpText = "go to a cube. ARG1: number of cube"

function goToCubeByCoordinates(coordinates, cubeSize, gridSpacing, duration) {
  const targetPosition = new THREE.Vector3(
    coordinates.x * (cubeSize + gridSpacing),
    coordinates.y * (cubeSize + gridSpacing),
    coordinates.z * (cubeSize + gridSpacing)
  );

  const startPosition = camera.position.clone();
  const startTime = Date.now();

  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = elapsed / duration;

    if (progress < 1) {
      camera.position.lerpVectors(startPosition, targetPosition, progress);
      requestAnimationFrame(animate);
    } else {
      camera.position.copy(targetPosition);
    }
  }

  animate();
}

function rotatex() {

  const xAxis = new THREE.Vector3(1, 0, 0);
   rotateCameraAroundAxis(xAxis, 15);

}
rotatex.helpText = "rotate around x axis 15 degrees";


function rotatey() {

        const yAxis = new THREE.Vector3(0, 1, 0);
        rotateCameraAroundAxis(yAxis, 15); 

}
rotatey.helpText = "rotate around y axis 15 degrees";


function rotatez() {

const zAxis = new THREE.Vector3(0, 0, 1);
rotateCameraAroundAxis(zAxis, 15); 

}
rotatez.helpText = "rotate around z axis 15 degrees";


function rotateCameraAroundXAxis(degrees) {

        const xAxis = new THREE.Vector3(1, 0, 0);
        rotateCameraAroundAxis(xAxis, degrees); // Rotate the camera 30 degrees around the X-axis

}
rotateCameraAroundXAxis.advancedHelpText = "rotate around x axis a certain number of degrees. ARG1:degrees";


function rotateCameraAroundYAxis(degrees) {

        const yAxis = new THREE.Vector3(0, 1, 0);
      rotateCameraAroundAxis(xAxis, degrees); // Rotate the camera 30 degrees around the X-axis

}
rotateCameraAroundYAxis.advancedHelpText = "rotate around y axis a certain number of degrees. ARG1:degrees";


function rotateCameraAroundZAxis(degrees) {

const zAxis = new THREE.Vector3(0, 0, 1);
rotateCameraAroundAxis(zAxis, degrees); // Rotate the camera 30 degrees around the X-axis

}
rotateCameraAroundZAxis.advancedHelpText = "rotate around y axis a certain number of degrees. ARG1:degrees";


function rotateCameraAroundAxis(axis, degrees) {
  // Convert degrees to radians
  const radians = (degrees * Math.PI) / 180;

  // Save the current camera position
  const currentPosition = camera.position.clone();

  // Create a new quaternion to represent the rotation
  const quaternion = new THREE.Quaternion();

  // Set the quaternion to represent a rotation around the specified axis
  quaternion.setFromAxisAngle(axis, radians);

  // Apply the rotation to the camera position
  currentPosition.applyQuaternion(quaternion);

  // Update the camera position
  camera.position.copy(currentPosition);

  // Make the camera look at the center
  camera.lookAt(new THREE.Vector3(0, 0, 0));
}

function zoomAndCreateSubCube(coordinates, cubeSize, gridSpacing, duration, depth, scale) {
  if (depth <= 0) {
    return;
  }

  goToCubeByCoordinates(coordinates, cubeSize, gridSpacing, duration);

  // Wait for the duration of the zoom before creating the subcube
  setTimeout(() => {
    // Create subcube inside the parent cube
    const parentCube = findCubeByCoordinates(coordinates, cubeSize, gridSpacing);
    const subCube = createCube(cubeSize * scale);
    parentCube.add(subCube);

    // Update the coordinates to zoom into the subcube
    const subCubeCoordinates = { x: 3, y: 3, z: 3 };

    // Update the cubeSize and gridSpacing based on the scale factor
    const subCubeSize = cubeSize * scale;
    const subGridSpacing = gridSpacing * scale;

    // Zoom into the subcube and create another subcube inside it
    zoomAndCreateSubCube(subCubeCoordinates, subCubeSize, subGridSpacing, duration, depth - 1, scale);
  }, duration);
}

function findCubeByCoordinates(coordinates, cubeSize, gridSpacing) {
  // Calculate the target position based on the coordinates, cubeSize, and gridSpacing
  const targetPosition = new THREE.Vector3(
    coordinates.x * (cubeSize + gridSpacing),
    coordinates.y * (cubeSize + gridSpacing),
    coordinates.z * (cubeSize + gridSpacing)
  );

  // Find the cube in the allCubes array based on its position
  const cube = allCubes.find((cube) => cube.position.equals(targetPosition));
  return cube;
}

function createCube(size) {
  const geometry = new THREE.BoxGeometry(size, size, size);
  const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  const cube = new THREE.Mesh(geometry, material);
  return cube;
}


function createTextMesh(text, size, callback) {
  const loader = new THREE.FontLoader();

  loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json', (font) => {
    const textGeometry = new THREE.TextGeometry(text, {
      font: font,
      size: size,
      height: 0.1,
      curveSegments: 12,
    });

    const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
    callback(textMesh);
  });
}


function animateText(text, start, end, duration) {
  // Create a text mesh
  createTextMesh(text, 1, (textMesh) => {
    // Set the initial position
    textMesh.position.set(start.x, start.y, start.z);

    // Add the text mesh to the scene
    scene.add(textMesh);

    // Animate the text mesh
    let startTime = null;
    function animate(timestamp) {
      if (!startTime) startTime = timestamp;
      const elapsed = timestamp - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // Update the position of the text mesh
      textMesh.position.lerpVectors(start, end, progress);

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        // Remove the text mesh from the scene when the animation is complete
        scene.remove(textMesh);
      }
    }

    requestAnimationFrame(animate);
  });
}

<!-- SECTION: Github -->

async function createChartDataURL(contributionsData) {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;

    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: contributionsData.map((dataPoint) => dataPoint.date),
        datasets: [
          {
            label: 'Contributions',
            data: contributionsData.map((dataPoint) => dataPoint.contributions),
            borderColor: 'rgba(75, 192, 192, 1)',
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
          },
        ],
      },
      options: {
        scales: {
          x: {
            display: false,
          },
          y: {
            display: false,
          },
        },
      },
    });

    chart.on('render', () => {
      resolve(canvas.toDataURL());
    });
  });
}

async function addChartToCube(cube, contributionsData) {
  const dataURL = await createChartDataURL(contributionsData);
  const texture = new THREE.TextureLoader().load(dataURL);
  const material = new THREE.MeshBasicMaterial({ map: texture });
  cube.material[0] = material; // Set the chart as the texture for one side of the cube
}

async function addGitHubContributionsChartToCube(cubeIndex) {
  // Fetch the contributions data for the GitHub repository
  const contributionsData = await fetchGitHubContributionsData('owner', 'repository'); // Replace 'owner' and 'repository' with the GitHub repository you want to visualize

  // Add the chart to the cube
  const cube = allCubes[cubeIndex];
  addChartToCube(cube, contributionsData);
}


async function fetchGitHubContributionsData(owner, repo) {
  const url = `https://api.github.com/repos/${owner}/${repo}/stats/participation`;
  const response = await fetch(url, {
    headers: {
      'Authorization': `Bearer ${process.env.GITHUB_ACCESS_TOKEN}`,
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch contributions data for ${owner}/${repo}`);
  }

  const data = await response.json();
  const contributionsData = data.all.map((contributions, index) => {
    const date = new Date();
    date.setDate(date.getDate() - (data.all.length - index));
    return { date, contributions };
  });

  return contributionsData;
}



<!-- SECTION: Basic Tests -->

// const cubeAt111 = getCubeByCoordinates(1, 1, 1);
// const cubeAtMinus111 = getCubeByCoordinates(-1, -1, -1);

// fetchMoleculeData('water').then((sdfData) => {
//   const molecule = parseSDF(sdfData);

//   console.log(molecule);
// });

<!-- SECTION: Labels -->

function setCubeLabel(cubeIndex, label) {
  allCubes[cubeIndex].label = label;
}

function findCubeByLabel(label) {we 
  return allCubes.find(cube => cube.label === label);
}


<!---  SECTION: terminal -->

function advanced() {
  let functionsList = [];

  for (const key in window) {
    if (typeof window[key] === 'function' && window[key].advancedHelpText) {
      functionsList.push(`${key}: ${window[key].advancedHelpText}`);
    }
  }

  if (functionsList.length === 0) {
    terminal.write('No functions with advancedHelpText found.');
  } else {
    const formattedList = functionsList.join('\r\n');
    terminal.write(`\r\nAvailable functions:\r\n${formattedList}\r\n$`);
  }
}
advanced.helpText = "displays advanced functions along with descriptions of how to use them";

function complete() {
  let functionsList = [];

  for (const key in window) {
    if (typeof window[key] === 'function' ) {
      functionsList.push(`${key}`);
    }
  }

  if (functionsList.length === 0) {
    terminal.write('No functions  found.');
  } else {
    const formattedList = functionsList.join('\r\n');
    terminal.write(`\r\nAvailable functions:\r\n${formattedList}\r\n$`);
  }
}
complete.advancedHelpText = "all functions";

function initializeTerminalHistory() {
  const terminalInput = document.querySelector('.terminal-input');
  if (terminalInput) {
    terminalInput.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowUp') {
        event.preventDefault();
        terminalInput.value = lastCommand;
      }
    });
  }
}

setTimeout(() => {
  initializeTerminalHistory();
  onTerminalReady();
}, 100);

function help() {
  let functionsList = [];

  for (const key in window) {
    if (typeof window[key] === 'function' && window[key].helpText) {
      functionsList.push(`${key}: ${window[key].helpText}`);
    }
  }

  if (functionsList.length === 0) {
    terminal.write('No functions with helpText found.');
  } else {
    const formattedList = functionsList.join('\r\n');
    terminal.write(`\r\nAvailable functions:\r\n${formattedList}\r\n$`);
  }
}
help.helpText = "displays available functions along with descriptions of how to use them";

function isNumeric(str) {
  if (typeof str != "string") return false // we only process strings!  
  return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...
         !isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail
}

// Create a new terminal instance
const terminal = new Terminal();
var lastAction = "";
// Create and load the addons
const fitAddon = new FitAddon.FitAddon();
terminal.loadAddon(fitAddon);
const webglAddon = new WebglAddon.WebglAddon();
terminal.loadAddon(webglAddon);

// Attach the terminal to the DOM element
terminal.open(document.getElementById('terminal'));

onTerminalReady();

// Fit the terminal to its container
fitAddon.fit();

// Set up a simple prompt
// terminal.write('Welcome to Jarca! Jarca is a fusion of GPT-Jargon and Arca. \r\n');
// const basicHelpString = 'Commands: "library" "play" "stop" "faster" "slower" "earth" "mars" "advanced" "help"   \r\n';
// terminal.write(basicHelpString);
terminal.write('\r\n$ ');

// const player = new Tone.Player('chopin_nocturne_20.mp3').toDestination();
// await Tone.start();

// Handle user input
let inputBuffer = '';
let lastCommand = '';

var player; 

terminal.onData((data) => {
  // If the user pressed Enter, process the command
  if (data === '\r') {
    const command = inputBuffer.trim();
    inputBuffer = '';
    console.log("User typed command:", command);

    // Split the command by semicolons
    const commands = command.split(';');

    commands.forEach((command) => {

      lastCommand = command;
      // Split the command by spaces
      const args = command.trim().split(/\s+/);
      const functionName = args.shift();

      // Check if the function exists and call it with the remaining arguments
      if (typeof window[functionName] === 'function') {
        try {
          window[functionName](...args);

        } catch (error) {
          console.error(`Error while executing function ${functionName}:`, error);
          terminal.write(`An error occurred while executing ${functionName}: ${error.message}`);
        }
      } else {
        terminal.write(`Unknown command: ${functionName}`);
      }
    
    });

    // Clear the line and print a new prompt
    terminal.write('\x1B[2K\x1B[G');
    terminal.write('$ ');


  } else if (data === '\x7F') {
    // If the user pressed Backspace, remove the last character from the input buffer

    inputBuffer = inputBuffer.slice(0, -1);
    terminal.write('\b \b');

  // Otherwise, add the character to the input buffer and display it in the terminal
  } else {
    inputBuffer += data;
    terminal.write(data);
  }



});

// terminal.onData((data) => {
//   // If the user pressed Enter, process the command
//   if (data === '\r') {
//     const command = inputBuffer.trim();
//     inputBuffer = '';
//     // Process the command
//     console.log("User typed command:", command);
//     //C4 D4 E4 F4 G4 A4 B4 C5
//     if(isNumeric(command))
//     {
//       // console.log ("isN");
//       // const lerpFactor = 1;
//       selectedCubeIndex = parseInt(command);
//       // const targetPosition = allCubes[selectedCubeIndex].position.clone().add(new THREE.Vector3(0, 0, 8));
//       // camera.position.lerp(targetPosition, lerpFactor);

//       goto(selectedCubeIndex); // Move the camera towards the cube at index 3



//     } else  if (lastAction == "claimed"){
//       socket.emit("claim", {"activeUser": activeUser, "cube": selectedCubeIndex, "name":command});
//       allCubes[selectedCubeIndex].name = "command";
//     } else if(command == 'help') {
//       terminal.write(basicHelpString);

//   } else if(command == 'create link') {
//       terminal.write(' Type "create link mars/2.3.4->www.mymetaverse.com/peace" \r\n');

//   } else if(command == 'count') {

//     var objectCount = countObjects(scene);
//     console.log("Total number of objects in the scene:", countObjects(scene));
//     terminal.write(objectCount + " active objects \r\n");

//   } else if(command == 'clean') {

//      garbageCollector(scene, .1);

//   } else if(command == 'hard clean') {

//       garbageCollector(scene, .5);

//   }
//   else if(command == 'advanced') {
//       terminal.write('  "NUMBER" "MOLECULE_NAME" "NUMBER+molecule name" "bpm" "count" "clean" "rotatex" "rotatey" "rotatez" "hamlet" \r\n');

//     } else if(command.includes(','))  {

//       playJourney(command.split(',').forEach( self.trim()));

//   } else if(command.includes('+'))  {
//     console.log("split");
//     const commandSequence = command.split('+');
//     if(commandSequence.length > 1)
//         anyMolecule(commandSequence[1], commandSequence[0]);
//     else
//       h2o(commandSequence[0], 0);


//   } else if(command == 'hamlet') {

//     const text = "To be or not to be";
// const start = new THREE.Vector3(100, 100, 100);
// const end = new THREE.Vector3(-5, -5, -5);
// const duration = 10000; // 5 seconds

// animateText(text, start, end, duration);

// } else if(command == 'maze') {

//       makeMeAMaze(allCubes[selectedCubeIndex]);

//   } else  if(command == 'castle') {

//           // Load the GLB file using the GLTFLoader
//           const loader = new GLTFLoader();
//           loader.load('https://multiversal.s3.us-east-2.amazonaws.com/5bd62a2a-0668-4ea2-b104-c575ba4fade3-1682691738/output.glb', (gltf) => {
//             // Create an Object3D to hold the GLB model
//             const model = new THREE.Object3D();

//             // Add the GLB model to the Object3D
//             model.add(gltf.scene);

//             // Scale and position the model to fit inside the cube
//             model.scale.set(0.1, 0.1, 0.1); // Adjust the scale as needed
//             model.position.set(0, 0, 0); // Adjust the position as needed

//             // Add the model to the cube
//             allCubes[selectedCubeIndex].add(model);
//           });

//           // Your animation loop
//           function animate() {
//             requestAnimationFrame(animate);
//             renderer.render(scene, camera);
//           }

//           animate();

// } else if(command == 'h2o' ||  command == 'water' ) {
//       // console.log("typed ox");
//       h2o(selectedCubeIndex, (Math.random() / 5));

//       // playJourney(selectedCube.uuid);

//   } else if(command == 'library') {

//       terminal.write(' Beethoven for op. 131. Chopin for Nocturne 20. Bach for BWV1007.\r\n');

//   } else if(command == 'claim') {

//       if(activeUser == "")
//         terminal.write('   You are not logged in. You cannot claim.\r\n');
//       else  
//       {
//         socket.emit("claim", {"activeUser": activeUser, "cube": selectedCubeIndex});
//         terminal.write('Cube ' + selectedCubeIndex + ' belongs to you. Please give it a name.\r\n');
//         lastAction = "claimed";

//       }


//     } else  if(command.includes('zoom')) {
//       // zoomAndCreateSubCube(subCubeCoordinates, subCubeSize, subGridSpacing, duration, depth - 1, scale);

//       zoomAndCreateSubCube({ x: 3, y: 3, z: 3 }, 1, 6, 8000, 7, 0.1);

// } else  if(command.includes('rotatex')) {
    
//         //     const yAxis = new THREE.Vector3(0, 1, 0);
//         // rotateCameraAroundAxis(yAxis, 45); // Rotate the camera 45 degrees around the Y-axis

//         const xAxis = new THREE.Vector3(1, 0, 0);
//         rotateCameraAroundAxis(xAxis, 45); // Rotate the camera 30 degrees around the X-axis

//         // const customAxis = new THREE.Vector3(1, 1, 1).normalize();
//         // rotateCameraAroundAxis(customAxis, 60); // Rotate the camera 60 degrees around a custom axis

//     } else  if(command.includes('rotatey')) {
    
//         const yAxis = new THREE.Vector3(0, 1, 0);
//         rotateCameraAroundAxis(yAxis, 45); // Rotate the camera 45 degrees around the Y-axis


//     // const customAxis = new THREE.Vector3(1, 1, 1).normalize();
//     // rotateCameraAroundAxis(customAxis, 60); // Rotate the camera 60 degrees around a custom axis

// } else  if(command.includes('rotatez')) {
    
//     const zAxis = new THREE.Vector3(0, 0, 1);
//     rotateCameraAroundAxis(zAxis, 45); // Rotate the camera 45 degrees around the Y-axis



// }  else if(command.toLowerCase() == 'earth') {
//       // player = new Tone.Player("snd/bach_remixbwv1007.mp3").toDestination();
//       // player.autostart = true;

cubeMap.set("earth", 123);
function earth() {

  playJourney([123]);
}
earth.helpText = "take me to earth";

//       selectedCubeIndex  = 123;
//       playJourney([123]);
//           // playMelody();
//     } else if(command.toLowerCase() == 'mars')  {
//       // player = new Tone.Player("snd/bach_remixbwv1007.mp3").toDestination();
//       // player.autostart = true;

cubeMap.set("mars", 124);
function mars() {

  playJourney([124]);
}
mars.helpText = "take me to mars";

      // selectedCubeIndex  = 124;
      // playJourney([124]);
//           // playMelody();
//     } else if(command.includes('Bach')) {
//       player = new Tone.Player("snd/bach_remixbwv1007.mp3").toDestination();
//       player.autostart = true;
//       playJourney([61,63,65,67,69,68,66,64,24]);
//           // playMelody();
//     } else if(command.includes('Beethoven')) {
//       // changeTextCubeColor(beethovenCube, 'red');
//       // player = new Tone.Player("snd/beethoven_op131_allegro_001.mp3").toDestination();
//       // const audioSource = audioContext.createMediaElementSource(audioElement);
//       // analyser = audioContext.createAnalyser();
//       // analyser.fftSize = 256;
//       // audioSource.connect(analyser);
//       // audioSource.connect(audioContext.destination);
//       // audioElement.play();
//     console.log("beethoven");
//     const audioContext = new AudioContext();
//     const audioElement = new Audio('snd/beethoven_symphony_n7.mp3');
//     const audioSource = audioContext.createMediaElementSource(audioElement);
//     analyser = audioContext.createAnalyser();
//     analyser.fftSize = 256;
//     audioSource.connect(analyser);
//     audioSource.connect(audioContext.destination);
//     audioElement.play();

//     bufferLength = analyser.frequencyBinCount;
//     dataArray = new Uint8Array(bufferLength);

//     //   player.autostart = true;
//       playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 120, 2, 3, 4, 70]);


//         function animate() {
//           requestAnimationFrame(animate);

//           updateColors();
//           renderer.render(scene, camera);
//       }

//       animate();


//           // playMelody();
//     } else if(command.includes('Chopin')) {
//       player = new Tone.Player("snd/chopin_nocturne_20.mp3").toDestination();
//           playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 120, 2, 3, 4, 70]);
//           // playMelody();
//           player.autostart = true;
//     } else if (command == 'play melody') {
//       playMelody(); 

//     } else if(command.startsWith('play') && command.length > 5)
//     {

//       const melody = command.substring(5,command.length);

//       const inputArray = melody.split(' ');
//       const outputArray = inputArray.map((note) => {
//         return { note: note, duration: "4n" };
//       });

//       // var playableMelody = [];
//       playMelody(outputArray);

      
//       // melody.split(' ').forEach({
//       //     //TODO: BUG in this line
//       //     // playableMelody.add({note: self, duration: '4n'});
        
//       // }
//     }  else if(command.startsWith('generate') && command.length > 8)
//     {

//       // const creature = command.substring(8,command.length);

//       const inputArray = command.split(' ');
//       if (inputArray[1])
//         generate(inputArray[1]);

//     }
        
//     else if(command == 'mine') {


//           terminal.write('you don\'t have enough monet to mine.\r\n');

//           // playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70]);

//          } else  if(command == 'stop') {
//           player.stop();
//           playJourney([]);

//          } else if(command.includes('bpm ')) {

//           const speed = command.substring(4,command.length);

//           bpm = parseInt(speed);
//           console.log(bpm);

//           // playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70]);

//          }  else if(command == 'faster') {
//           bpm += 10;
//           console.log(bpm);

//           // playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70]);

//          } else if(command == 'slower') {
//           bpm -= 10;
//           console.log(bpm);
//           // playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70]);

//          } else 
//          {

//           anyMolecule(command, selectedCubeIndex) 

//          }

         
//     // Clear the line and print a new prompt
//     terminal.write('\x1B[2K\x1B[G');
//     terminal.write('$ ');

//   // If the user pressed Backspace, remove the last character from the input buffer
//   } else if (data === '\x7F') {
//     inputBuffer = inputBuffer.slice(0, -1);
//     terminal.write('\b \b');

//   // Otherwise, add the character to the input buffer and display it in the terminal
//   } else {
//     inputBuffer += data;
//     terminal.write(data);
//   }
// });




function onTerminalReady() {
  terminal.clear();
  terminal.write('Type "help" for a list of available functions, or view the initial list below:\r\n');
  terminal.write(listFunctionNames().toString());
  terminal.write("\r\n$ ");

}

function listFunctionNames() {
  let functionsList = [];


  for (const key in window) {
    // console.log(key);
    if (typeof window[key] === 'function' && window[key].helpText) {

      functionsList.push(` ${key}`);
    }
  }

  // console.log(functionsList);

  return functionsList;
}

function listAdvancedFunctionNames() {
  let functionsList = [];


  for (const key in window) {
    // console.log(key);
    if (typeof window[key] === 'function' && window[key].advancedHelpText) {

      functionsList.push(` ${key}`);
    }
  }

  console.log(functionsList);

  return functionsList;
}

<!-- SECTION: JARGON -->


async function games() {
  try {
    const response = await fetch('/jarg-list');
    const files = await response.json();
    terminal.write(`Available games: ${files.join(', ')} Type "play" and then the game name to play game.\n\r$ `);
  } catch (error) {
    console.error('Error fetching jarg files:', error);
    terminal.write('Error fetching jarg files');
  }
}
games.helpText = "list available games"


// const fs = require("fs")

    </script>




</body>
</html>
