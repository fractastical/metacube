<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metacube</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        .login-section {
              position: fixed;
              top: 0;
              left: 0;
              right: 0;
              height: 50px;
              background-color: #333;
              display: flex;
              align-items: center;
              justify-content: flex-end;
              padding-right: 20px;
            }

            button {
              background-color: #171a21;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 10px 20px;
              font-size: 16px;
              cursor: pointer;
            }

            button:hover {
              background-color: #1d1f27;
        }

        #terminal {
            width: 100%;
            background-color: black;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;

          }


    </style>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.30/Tone.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
<!-- DUD from GPT-4 <script src="https://steamcommunity.com/public/javascript/webui/webui.js"></script> -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<!--<script src="https://cdn.skypack.dev/pin/three@v0.136.0-4Px7Kx1INqCFBN0tXUQc/mode=imports,min/unoptimized/examples/jsm/renderers/CSS3DRenderer.js"></script>-->
<!-- <script src="https://threejs.org/examples/jsm/renderers/CSS3DRenderer.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/midi-player-js@2.0.12/dist/MidiPlayer.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />

<!-- Xterm.js and addons scripts -->
<script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-webgl/lib/xterm-addon-webgl.js"></script>

</head>
<body>

    <div class="login-section">

      <!-- <input type="text" value="cheese" /> -->
      <div id="balance" style="color:white; text-align:left">Credits: 0</div>
  <!--  <input id="journeyData" value="your journey data here"  type="text" onchange="playJourney()" size="20"/>-->
      <button id="loginWithMetamask">Login with MetaMask</button>
    
      <img  onclick="playJourney()" src="img/steam-login.png"/>


    </div>
    <div id="terminal"></div>

    <div id="hypercube"></div>

    <script>

        var allVisitedCubes = {};
        var allCubes = [];
        const socket = io();
        var credits = 10;


        // TODO: I think this doesn't work becauese scene hasn't rendered :(

        socket.on('visitedCubes', visitedCubes => {

              // console.log("cubesinbound:" + visitedCubes.length);
              // console.log(visitedCubes);
              allVisitedCubes = visitedCubes;

              Object.keys(allVisitedCubes).forEach(cubeId => {
                // console.log("updating " + cubeId);


              var thiscube = scene.getObjectByProperty("uuid", cubeId);
              //  always undefined
              console.log(thiscube);
              if (thiscube) {
                  console.log("segmenting " + cubeId);

                const outline = thiscube.getObjectByProperty("type", "LineSegments");
                if (outline) {
                    console.log("bluying " + cubeId);

                  outline.material.color.set("blue");
                }
          }
        });
     });



        socket.on("cubeVisited", (cubeId) => {

        // console.log("visit:" + cubeId);

          const cube = scene.getObjectByProperty("uuid", cubeId);
          if (cube) {
            const outline = cube.getObjectByProperty("type", "LineSegments");
            if (outline) {
                     console.log("blue-ing visited " + cubeId);
                    selectedCube = cubeId;
                    outline.material.color.set("blue");
                    const synth = new Tone.Synth().toDestination();
                    Tone.start();
                    if (cubeId == 63)
                       enterMinkowskiSound();
                    else 
                      synth.triggerAttackRelease(cube.userData.frequency, "8n");


            }
          }
        });



        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        const cubeSize = 10;
        const cubeDistance = 60;

        const textureLoader = new THREE.TextureLoader();
        // const imageTexture = textureLoader.load('img/jd.jpeg');


    const textures = [
      textureLoader.load('https://f8n-production.imgix.net/creators/profile/47zx5exuz-cryptoapollo-jpg-hgsplk.jpg?auto=format%2Ccompress&q=50&w=128&h=128&fit=crop&dpr=2'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0xB7A1E2282974a42BC30D36eBdc7E7BcdcB8E4d28/28/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0x70fB56F898E44D70C1f7C1E2a9ca14c33cFDC6c5/5/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0x866b27fc857D16Aaaf7e2f7846EFe95747385fE0/3/nft.png?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0x93A430DfFDC5f79D2d8Ca574C137a124aD1a21C4/4/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0x79aB1115533B86d032BEA40ce63eB74E323f9eA4/1/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0xbc342b06b912C50eAc9C094b10cd2B8d30152d2b/3/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0xABB3738f04Dc2Ec20f4AE4462c3d069d02AE045B/11542018/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('https://f8n-production-collection-assets.imgix.net/0xBda03C0C791b80061B90F176E6F45E685A94C36c/4/nft.jpg?q=80&auto=format%2Ccompress&cs=srgb&w=3000&h=3000&fit=max'),
      textureLoader.load('/img/ai/1.jpeg'),
      textureLoader.load('/img/ai/2.jpeg'),
      textureLoader.load('/img/ai/3.jpeg'),
      textureLoader.load('/img/ai/4.png'),
      textureLoader.load('/img/ai/5.jpeg'),
      textureLoader.load('/img/ai/6.jpeg'),
      textureLoader.load('/img/ai/7.jpeg'),
      textureLoader.load('/img/ai/8.png'),
      textureLoader.load('/img/ai/9.jpeg'),
      textureLoader.load('/img/ai/10.jpeg'),
      textureLoader.load('/img/ai/11.png'),
      textureLoader.load('/img/ai/12.png'),
      textureLoader.load('/img/ai/13.jpeg'),
      textureLoader.load('/img/ai/14.png'),
      textureLoader.load('/img/ai/15.png'),
      textureLoader.load('/img/ai/16.png'),
      textureLoader.load('/img/ai/17.png'),
      textureLoader.load('/img/ai/18.png'),
      textureLoader.load('/img/ai/19.jpeg'),
      textureLoader.load('/img/ai/20.jpeg'),
      textureLoader.load('/img/ai/21.jpeg'),
      textureLoader.load('/img/ai/22.jpeg'),
      textureLoader.load('/img/ai/23.png')


    ];

    

        // const imageTexture = textureLoader.load('https://i.seadn.io/gae/9PTBw2m23Lrcol5YURG7iIIgKgYTPUO77FekvX1JyMIEzBK5mayjLWH00WFPHOP0OqJF7f3Xr9E2kxuXIiHJXViw7qHB6_mqBZYnx5c?auto=format&w=2048');


        // var labelRenderer = new CSS3DRenderer();
        // labelRenderer.setSize( innerWidth, innerHeight );
        // labelRenderer.domElement.style.position = 'absolute';
        // labelRenderer.domElement.style.top = '0px';
        // document.body.appendChild( labelRenderer.domElement );



        function createSphere(x, y, z, radius, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            scene.add(sphere);
            return sphere;
        }

    function getRandomTexture() {
      const index = Math.floor(Math.random() * textures.length);
      return textures[index];
    }

        function createCubeWithUniqueObject(x, y, z, opacity, geometryType, cubeNumber, modelUrl) {

                if (modelUrl) {
                        loadModel(modelUrl, smallCube);
                }

            // const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });
            // const cube = new THREE.Mesh(geometry, material);
            const edgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize));
            var lineMaterial;
            // console.log(allVisitedCubes);
            if(allVisitedCubes[cubeNumber])
                lineMaterial = new THREE.LineBasicMaterial({ color: blue, transparent: true, opacity: opacity });
            else
                lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: opacity });

            const cube = new THREE.LineSegments(edgesGeometry, lineMaterial);
            cube.uuid = cubeNumber;


            const smallEdgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(.2, .2, .2));

            const smallCube = new THREE.LineSegments(smallEdgesGeometry, lineMaterial);

            smallCube.position.set(x+3, y+3, z+3);
            scene.add(smallCube);


            const imageDisplay = createImageDisplay(getRandomTexture());

            // Position the image display inside the cube
            imageDisplay.position.set(x-4, y-4, z-4);
            // imageDisplay.rotation.y = Math.PI / 4;
            // imageDisplay.offset.y = 1;
            // imageDisplay.repeat.y = -1;

            // Add the image display to the cube
            scene.add(imageDisplay);


            cube.position.set(x, y, z);
            scene.add(cube);

// CSS3DObject not loading 
            // var div = document.createElement( 'div' );
            // div.className = 'label';
            // div.textContent = '1';
            // var label = new CSS3DObject( div );
            // label.position.copy(pos);
            // label.rotation.y = Math.PI * 0.5;
            // label.scale.set(0.025, 0.025, 1);
            // cube.add( label );



            // Store a random    for each cube
            // TODO: update this 
            cube.userData.frequency = 440 * Math.pow(2, (Math.floor(Math.random() * 12) - 9) / 12);

            const uniqueObject = createUniqueObject(x, y, z, geometryType);
            var textLabel;
            if (cube.name && cube.name.length > 2)
            {
              textLabel = cube.name;
            }
            else {
                textLabel=  createTextLabel(`Cube ${cubeNumber} ${uniqueObject.name}`);
           }

          // const textLabel = createTextLabel(`Cube 22: ${uniqueObject.name}`);

          textLabel.position.set(5.5, 0, 0); // Position the text label on the side of the cube
          cube.add(textLabel);
                // Create an invisible mesh for click detection
            const invisibleMeshGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const invisibleMeshMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const invisibleMesh = new THREE.Mesh(invisibleMeshGeometry, invisibleMeshMaterial);
            invisibleMesh.position.set(x, y, z);
            scene.add(invisibleMesh);

            invisibleMesh.userData.parentCube = cube;
            allCubes.push(cube);  
            return { cube, uniqueObject, invisibleMesh, smallCube };
        }


function createUniqueObject(x, y, z, type) {
    let geometry;

    // Calculate the distance between the geometry and the center of the grid
    const center = new THREE.Vector3(0, 0, 0);
    const currentPosition = new THREE.Vector3(x, y, z);
    const distanceToCenter = currentPosition.distanceTo(center);

    // Calculate the maximum possible distance
    const gridSize = 9;
    const cubeDistance = cubeSize + 60;
    const maxDistance = Math.sqrt(Math.pow((gridSize * cubeDistance) / 2, 2) * 3);

    // Generate a shade of purple based on the distance to the center
    const lightness = Math.floor((distanceToCenter / maxDistance) * 110);
    const purpleColor = new THREE.Color(`hsl(270, 100%, ${lightness}%)`);

    const material = new THREE.MeshBasicMaterial({ color: purpleColor });

    switch (type) {
        case 'sphere':
            geometry = new THREE.SphereGeometry(cubeSize / 2, 32, 32);
            break;
        case 'torus':
            geometry = new THREE.TorusGeometry(cubeSize / 4, cubeSize / 8, 16, 100);
            break;
        case 'tetrahedron':
            geometry = new THREE.TetrahedronGeometry(cubeSize / 2);
            break;
        case 'cone':
            geometry = new THREE.ConeGeometry(cubeSize / 2, cubeSize, 32);
            break;
        case 'cylinder':
            geometry = new THREE.CylinderGeometry(cubeSize / 2, cubeSize / 2, cubeSize, 32);
            break;
        case 'icosahedron':
            geometry = new THREE.IcosahedronGeometry(cubeSize / 2);
            break;
        case 'octahedron':
            geometry = new THREE.OctahedronGeometry(cubeSize / 2);
            break;
        case 'torusKnot':
            geometry = new THREE.TorusKnotGeometry(cubeSize / 4, cubeSize / 8, 100, 16);
            break;
        case 'dodecahedron':
            geometry = new THREE.DodecahedronGeometry(cubeSize / 2);
            break;
    }

    const object = new THREE.Mesh(geometry, material);
    object.scale.set(.5, .5, .5);

    object.position.set(x, y, z);
    scene.add(object);
    return object;
}


const cubeObjects = [];


function loadModel(url, parentObject) {
    const loader = new THREE.GLTFLoader();

    loader.load(url, (gltf) => {
        const model = gltf.scene;
        model.scale.set(0.01, 0.01, 0.01); // Scale down the model
        model.position.set(0, 0, 0); // Center the model inside the cube
        parentObject.add(model);
    });
}


function createGridOfCubes() {
    const geometryTypes = [
        'icosahedron',
        'dodecahedron',
        'octahedron',
        'tetrahedron',
        'torus',
        'cone',
        'torusKnot',
        'sphere',
        'sphere'


    ];

    const gridSize = 5;
    const cubeDistance = cubeSize + 60;
    var cubeNumber = 1;
    var selectedCube = "";

    for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
            for (let z = 0; z < gridSize; z++) {
                const xPos = x * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;
                const yPos = y * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;
                const zPos = z * cubeDistance - (gridSize * cubeDistance) / 2 + cubeSize / 2;

                // Use the geometry type from the geometryTypes array corresponding to the z index
                const geometryType = geometryTypes[z];

                createCubeWithUniqueObject(xPos + 30, yPos + 30, zPos + 30, 0.5, geometryType, cubeNumber);
                   
                cubeNumber++; 
            }
        }
    }
}


        function createGridOfCubesWithSpheres(size) {
            const grid = [];
            const offset = Math.floor(size / 2) * cubeDistance;
            for (let x = -offset; x <= offset; x += cubeDistance) {
                for (let y = -offset; y <= offset; y += cubeDistance) {
                    for (let z = -offset; z <= offset; z += cubeDistance) {
                        const opacity = (x === 0 && y === 0 && z === 0) ? 0.5 : 1;
                        const cubeWithSphere = createCubeWithUniqueObject(x, y, z, opacity);
                        grid.push(cubeWithSphere);
                    }
                }
            }
            return grid;
        }

        const gridOfCubesWithSpheres = createGridOfCubes(9);

        camera.position.z = 300;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let clickedObject = null;

        // function animate() {
        //     requestAnimationFrame(animate);

        //     gridOfCubesWithSpheres.forEach(obj => {
        //         obj.cube.rotation.x += 0.01;
        //         obj.cube.rotation.y += 0.01;
        //     });

        //     renderer.render(scene, camera);
        // }

async function onDocumentMouseDown(event) {
    event.preventDefault();
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
        clickedObject = intersects[0].object;

        if (clickedObject.geometry.type === "BoxGeometry") {
            const parentCube = clickedObject.userData.parentCube;
            const targetPosition = parentCube.position.clone().add(new THREE.Vector3(0, 0, cubeSize * 2.5));

            // Animate camera position using Tween.js with a slower zoom (3 seconds)
            const tween = new TWEEN.Tween(camera.position)
                .to(targetPosition, 3000)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate(() => {
                    controls.update();

                })
                .start();

            // When an object in the scene is manipulated, send an update to the server
            // socket.emit("sceneUpdate", "visiting ");
                // console.log(parentCube.uuid);
            socket.emit("cubeVisited", parentCube.uuid);

            controls.target.copy(parentCube.position);
            // takeSnapshot(parentCube);


            // Play sound with the frequency stored in the clicked cube
            // const synth = new Tone.Synth().toDestination();
            // await Tone.start();
            // synth.triggerAttackRelease(parentCube.userData.frequency, "8n");
        }
    }
}

        let edgeFadeDirection = 1;
        let edgeOpacity = 0;

        // In your Three.js script
        function checkForVisitedCubes() {
          const thresholdDistance = 50; // Adjust this value as needed

          for (const cube of cubeObjects) {
            const distance = cursor.position.distanceTo(cube.position);
            if (distance < thresholdDistance) {
              socket.emit("cubeVisited", cube.uuid);
              break;
            }
          }
        }



        function animate() {


                requestAnimationFrame(animate);

                // Fade the edges in and out
                // edgeOpacity += edgeFadeDirection * 0.01;
                // if (edgeOpacity >= 1) {
                //     edgeFadeDirection = -1;
                // } else if (edgeOpacity <= 0) {
                //     edgeFadeDirection = 1;
                // }

            scene.traverse(child => {
                if (child.isMesh && child.material instanceof THREE.LineBasicMaterial) {
                    child.material.opacity = edgeOpacity;
                    child.material.transparent = true;
                    child.material.needsUpdate = true;
                } else if (child.isMesh) {
                    child.rotation.x += 0.002;
                    child.rotation.y += 0.002;
                }
            });

            checkForVisitedCubes();

            TWEEN.update();

            renderer.render(scene, camera);
            controls.update();

        }


const pointLight = new THREE.PointLight(0xffffff, 0.5);
pointLight.position.set(0, 0, 100);
scene.add(pointLight);

        animate();
        window.addEventListener('mousedown', onDocumentMouseDown, false);

<!-- JSONparser section --> 

// Sample JSON from Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e
// URL https://jmkre9md1i.execute-api.eu-central-1.amazonaws.com/stage/land/Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e/assets

var jsonString='{"message":"Success","data":{"items":[{"verticesCount":1949,"rotation":"P=0.000000 Y=90.000000 R=-0.000000","objectId":"SM_Eris_01","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-1a86ac5d-b6d6-4b21-a1c5-06fee764d868-896ac586-85f0-44f4-82b8-5d969ef810fe","thumbnail":{"url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/3041b2cf-9fe3-4df6-8474-8493ea7711cc/SM_Eris_01.jpg","id":"File-3041b2cf-9fe3-4df6-8474-8493ea7711cc"},"description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/1a86ac5d-b6d6-4b21-a1c5-06fee764d868/SM_Eris_01.glb","position":"X=155339.335 Y=-253611.600 Z=107672.749","scale":"X=100.000 Y=100.000 Z=100.000","title":"SM_Eris_01.glb"},{"verticesCount":1949,"rotation":"P=0.000000 Y=90.000000 R=-0.000000","objectId":"SM_Sun_01","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-2c30b72d-f741-4cda-83fa-9d29a2fc69be-063d65ae-1a24-4366-91a5-6b37347f5e0a","thumbnail":{"url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/2d53de48-a259-479e-b2c6-a12f2f102862/SM_Sun_01.jpg","id":"File-2d53de48-a259-479e-b2c6-a12f2f102862"},"description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/2c30b72d-f741-4cda-83fa-9d29a2fc69be/SM_Sun_01.glb","position":"X=215512.640 Y=-202823.598 Z=156554.052","scale":"X=100.000 Y=100.000 Z=100.000","title":"SM_Sun_01.glb"},{"verticesCount":1949,"rotation":"P=0.000000 Y=90.000000 R=-0.000000","objectId":"SM_Moon_01","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-333c34d5-eb27-4175-be8f-cae87aa0d855-4fda87fd-d256-49b0-9f73-044c4ce38103","thumbnail":{"url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/ccc78f73-3235-40dc-85c1-1aba2dbf8b57/SM_Moon_01.jpg","id":"File-ccc78f73-3235-40dc-85c1-1aba2dbf8b57"},"description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/333c34d5-eb27-4175-be8f-cae87aa0d855/SM_Moon_01.glb","position":"X=136794.360 Y=-253178.753 Z=128042.662","scale":"X=100.000 Y=100.000 Z=100.000","title":"SM_Moon_01.glb"},{"verticesCount":0,"rotation":"P=0.000000 Y=180.000000 R=0.000000","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-8c9e0cda-03eb-43c0-85d3-2d10fd88a36d-85522845-c0ac-499d-978c-10b97ae92de8","description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/8c9e0cda-03eb-43c0-85d3-2d10fd88a36d/VR_blob3g.fbx","position":"X=7949.289 Y=-173781.646 Z=-422593.657","scale":"X=0.000 Y=0.000 Z=0.000","title":"VR_blob3g.fbx"},{"verticesCount":11859,"rotation":"P=0.000000 Y=90.000000 R=-0.000000","objectId":"Snow","_id":"Land-22521d7e-e5e8-4f90-86a2-a772a42f4e0e","SK":"L-Asset-b739c4eb-2f74-442e-93cd-e295e66fbc7a-717a9f44-8726-4884-92eb-1bfd156907c7","thumbnail":{"url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/fce0662c-7c5e-4f71-a863-3450f32dd773/Snow.jpg","id":"File-fce0662c-7c5e-4f71-a863-3450f32dd773"},"description":"","url":"https://metameta-assets-stage.s3.eu-central-1.amazonaws.com/b739c4eb-2f74-442e-93cd-e295e66fbc7a/Snow.glb","position":"X=0.000 Y=0.000 Z=-16940.967","scale":"X=100.000 Y=100.000 Z=100.000","title":"Snow.glb"}]}}';

function JSONparser(jsonString)  {
        // Parse the JSON data
        const jsonData = JSON.parse(jsonString);

        // Choose an item from the "items" array in the JSON data
        const item = jsonData.data.items[0]; // Select the first item in the array

        // Extract the model URL, position, and scale from the item
        const modelUrl = item.url;

        // Parse the position string and extract the X, Y, and Z values
        const positionMatch = item.position.match(/X=(-?\d+(\.\d+)?) Y=(-?\d+(\.\d+)?) Z=(-?\d+(\.\d+)?)/);
        const posX = parseFloat(positionMatch[1]);
        const posY = parseFloat(positionMatch[3]);
        const posZ = parseFloat(positionMatch[5]);

        // Parse the scale string and extract the X, Y, and Z values
        const scaleMatch = item.scale.match(/X=(-?\d+(\.\d+)?) Y=(-?\d+(\.\d+)?) Z=(-?\d+(\.\d+)?)/);
        const scaleX = parseFloat(scaleMatch[1]);
        const scaleY = parseFloat(scaleMatch[3]);
        const scaleZ = parseFloat(scaleMatch[5]);

        // Replace these variables with the actual values you want to use
        const targetOpacity = 0.5;
        const targetGeometryType = 'BoxGeometry';



    // Call the createCubeWithUniqueObject function with the model URL as an argument
    const cube = createCubeWithUniqueObject(scene, targetX, targetY, targetZ, targetOpacity, targetGeometryType, 1, modelUrl);

}


<!-- login section --> 
var activeUser = "";

async function loginWithMetaMask() {
  // Check if MetaMask is installed
  if (typeof window.ethereum === "undefined") {
    alert("Please install MetaMask to use this feature.");
    return;
  }

  try {
    // Request the user's Ethereum address
    const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
    const userAddress = accounts[0];
    activeUser = userAddress;
    // Use the Ethereum address as a unique identifier for the user
    console.log("User's Ethereum address:", userAddress);
    socket.emit("ethAddress", userAddress);


      try {
      const response = await fetch(`/balance/${userAddress}`);
      if (response.ok) {
        const data = await response.json();
        const balance = data.balance;
        console.log('Balance:', balance);
        // Display the balance on the page, e.g., update the DOM with the balance value
      } else {
        console.error('Error fetching balance:', response.statusText);
      }
    } catch (error) {
      console.error('Error fetching balance:', error);
    }

    // const balance = await getUserBalance(userAddress);
    // updateBalanceDisplay(balance);


    // Authenticate the user and proceed with your app's login flow
    // Example: store the user's Ethereum address in a cookie or session, fetch user data from your server, etc.
  } catch (error) {
    console.error("Error logging in with MetaMask:", error);
    alert("Login with MetaMask failed.");
  }
}


<!--  Does not work out of box from GPT-4 seems to require a generic openID oauth libary --> 

// Add a click event listener to the MetaMask login button
document.getElementById("loginWithMetamask").addEventListener("click", loginWithMetaMask);

// Replace 'YOUR_API_KEY' with your actual Steam Web API key
const API_KEY = '633FAC6F87C73A7A24676D7C4D4D6AC0';

// Initiate Steam login and handle the response
function steamLogin() {
  playJourney();
  // var login = new SteamLogin();
  // login.openidPopup('https://steamcommunity.com/openid/', 'https://yourwebsite.com/auth', handleLoginResponse);
}

// Handle the login response
function handleLoginResponse(response) {
  if (response && response.oauth_token) {
    // The user has successfully logged in
    // You can now use the Steam Web API to access the user's information
    const oauthToken = response.oauth_token;
    getUserInfo(oauthToken);
  } else {
    // The user has canceled the login process
  } 
}

// Retrieve the user's information from the Steam Web API
function getUserInfo(oauthToken) {
  const url = `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=${API_KEY}&format=json&access_token=${oauthToken}`;
  fetch(url)
    .then(response => response.json())
    .then(data => {
      // Parse the response to get the user's information
      const userInfo = data.response.players[0];
      console.log(userInfo);
    })
    .catch(error => {
      console.error(error);
    });
}


<!-- SECTION: image manipulation libaray  --> 




function createImageDisplay(imageTexture) {
  const geometry = new THREE.PlaneGeometry(3, 3);
  const material = new THREE.MeshBasicMaterial({ map: imageTexture, transparent: true });
  const imageDisplay = new THREE.Mesh(geometry, material);
  
  return imageDisplay;
}


function createTextTexture(text) {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');

  canvas.width = 256;
  canvas.height = 256;

  // Draw a background (optional)
  context.fillStyle = 'black';
  context.fillRect(0, 0, canvas.width, canvas.height);

  // Draw the text
  context.font = '48px sans-serif';
  context.fillStyle = 'white';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.fillText(text, canvas.width / 2, canvas.height / 2);

  const texture = new THREE.CanvasTexture(canvas);
  return texture;
}


function createTextLabel(text) {
  const textTexture = createTextTexture(text);
  const geometry = new THREE.PlaneGeometry(1, 1);
  const material = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
  const textLabel = new THREE.Mesh(geometry, material);

  return textLabel;

}

<!-- SECTION: sound -->

    // locking cubes 0-127 to MIDI note numbers
    // The range of MIDI note numbers spans from 0 to 127, providing a total of 128 unique note numbers. This range covers a little over 10 octaves, with each octave containing 12 notes (including sharps and flats).
    // The lowest MIDI note number, 0, corresponds to C-1 (C minus one), while the highest, 127, corresponds to G9. Middle C (C4) has a MIDI note number of 60. The MIDI note numbers are used to represent pitches and trigger sounds on MIDI-compatible devices and software synthesizers.

// Cube 63 currently assigned to MinkowskiSound

var MidiPlayer = require('midi-player-js');

// import { Player } from 'midi-player-js';

// Load the MIDI file
const midiFileUrl = 'beethoven_op131_allegro_001_piano.mid';

// Create a new player
const player = new Player();

// Load the MIDI file into the player
player.loadFile(midiFileUrl);

// Set up an event listener for MIDI events
player.on('midiEvent', (event) => {
  // Look for 'Note on' events with a non-zero velocity
  if (event.name === 'Note on' && event.velocity > 0) {
    const note = event.noteNumber;

    // Use the note value to determine which cube to highlight or visit
    const cubeIndex = note % (gridSize * gridSize * gridSize); // Assuming a 9x9x9 grid of cubes
    // const cube = cubes[cubeIndex];

    // Highlight the cube or start a journey to the cube
    // You can use your existing functions or create new ones to handle this
  }
});

// Start playing the MIDI file
player.play();

/*

For the sake of the thought experiment, let's consider a single wave propagating through a hypothetical medium in Minkowski spacetime. In a typical 3D space, the wave equation for sound is given by:

∇²p - (1/c²)∂²p/∂t² = 0

where ∇² is the Laplacian operator, p is the pressure disturbance in the medium, c is the speed of sound in the medium, and t is time.

To adapt this to Minkowski spacetime, we will treat the wave as a scalar field ψ in a four-dimensional spacetime with coordinates (t, x, y, z). The Minkowski metric is given by:

η = diag(-1, 1, 1, 1)

The wave equation in Minkowski spacetime for a scalar field becomes:

□ψ = 0

where □ is the d'Alembertian operator, defined as:

□ = η^(μν) ∂_μ ∂_ν

Here, η^(μν) are the components of the inverse Minkowski metric, and ∂_μ and ∂_ν are partial derivatives with respect to the spacetime coordinates. In the Cartesian coordinates, the d'Alembertian operator can be expressed as:

□ = -∂²/∂t² + ∂²/∂x² + ∂²/∂y² + ∂²/∂z²

Now, let's assume that the speed of sound in our hypothetical medium is 'c', and the wave equation for a single wave in Minkowski spacetime is:

□ψ = (1/c²)∂²ψ/∂t² - ∂²ψ/∂x² - ∂²ψ/∂y² - ∂²ψ/∂z² = 0

Keep in mind that this is a highly speculative scenario, and the behavior of sound waves in Minkowski spacetime is not well-defined in physics. Nonetheless, this adapted wave equation represents a starting point for exploring how a single wave might propagate in a Minkowski-like spacetime. The perception and interpretation of this wave by an observer in this four-dimensional spacetime would be influenced by time dilation and length contraction effects.

The JavaScript implementation provided earlier does not directly translate into sound, as it simulates the time evolution of a scalar field in a hypothetical 1D Minkowski spacetime. The behavior of sound waves in Minkowski spacetime is not well-defined in physics, and the program serves merely as an example of how one might attempt to simulate a scalar field in a Minkowski-like spacetime.


*/

    function enterMinkowskiSound() {

// Parameters
const c = 1; // Speed of sound in the hypothetical medium
const N = 100; // Number of spatial points
const dx = 1; // Spatial step
const dt = 0.5; // Time step
const tMax = Math.floor(2 * 44100 / N); // Time steps for 7 seconds of audio

// Initialize scalar field
const psi = new Array(N).fill(0);

// Initial condition (single wave at the center)
psi[Math.floor(N / 2)] = 1;

// Initialize audio context
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// Create audio buffer
const audioBuffer = audioCtx.createBuffer(1, tMax * N, audioCtx.sampleRate);

// Time evolution
for (let t = 0; t < tMax; t++) {
  const psiNext = new Array(N).fill(0);

  for (let i = 1; i < N - 1; i++) {
    psiNext[i] = 2 * psi[i] - psi[i - 1] + (c * c * dt * dt / (dx * dx)) * (psi[i + 1] - 2 * psi[i] + psi[i - 1]);
  }

  // Update the scalar field
  for (let i = 0; i < N; i++) {
    psi[i] = psiNext[i];
  }

  // Write scalar field values to audio buffer
  const buffer = audioBuffer.getChannelData(0);
  for (let i = 0; i < N; i++) {
    buffer[t * N + i] = psi[i];
  }
}

// Play the audio buffer with volume control
const playAudioBuffer = () => {
  const source = audioCtx.createBufferSource();
  const gainNode = audioCtx.createGain();

  source.buffer = audioBuffer;
  source.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  // Set the initial gain value for a softer sound
  gainNode.gain.setValueAtTime(0.01, audioCtx.currentTime);

  // Apply an exponential ramp to the gain value for smoother volume control
  gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 2);

  source.start();
};

playAudioBuffer();
}



    const synth = new Tone.Synth().toDestination();

    // Create a journey through the cubes
    var journeyOrder = [0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70];
    var journeyIndex = 0;
    var bpm = 60;
    var journeyData = document.getElementById('terminal').value;
    // const frequencies = generateFrequencies(261.63, 100);
    const allFrequencies = generateFrequencies(allCubes.length)

    function generateFrequencies(startFrequency, numNotes) {
        const ratio = Math.pow(2, 1 / 12); // 12th root of 2
        const frequencies = [startFrequency];

        for (let i = 1; i < numNotes; i++) {
          const frequency = startFrequency * Math.pow(ratio, i);
          frequencies.push(frequency);
        }

        return frequencies;
}

    
    // Play the notes associated with the cubes in the journey
    async function playJourney(path) {

      const clock = new THREE.Clock();

      const timeBetweenNotes = '8n';
        
          Tone.start();
          let movementProgress = 0;
          var movementDuration = 1 / (bpm/60);

        // const sequence = new Tone.Sequence((time, index) => {
        //     currentCubeIndex = journey[index];
        //     const cube = allCubes[currentCubeIndex];
        //     const note = cube.note;
        //     synth.triggerAttackRelease(note, timeBetweenNotes, time);
        // }, journey, timeBetweenNotes);

        // const moveCamera = () => {
        //     const targetCube = allCubes[journeyOrder[journeyIndex]];
        //     // synth.triggerAttackRelease(targetCube.userData.frequency, "8n");

        //     camera.position.x += (targetCube.position.x - camera.position.x) * 0.05;
        //     camera.position.y += (targetCube.position.y - camera.position.y) * 0.05;
        //     camera.lookAt(targetCube.position);
        // };
        // journeyData = path;

        journeyOrder = path;

        // journeyData = journeyOrder.toString(); 
        // document.getElementById('terminal').value = journeyData;

        const animate = function () {
              const deltaTime = clock.getDelta();
              movementDuration = 1 / (bpm/60);
              movementProgress += deltaTime;
              if(journeyOrder && journeyOrder.length > 1 )
              {
              if (movementProgress >= movementDuration) {
                  // Move to the next cube in the journeyOrder array
                  journeyIndex = (journeyIndex + 1) % journeyOrder.length;

                  // Reset movement progress
                  movementProgress = 0;

                  // Play the note associated with the current cube
                  // const frequency = cubeFrequencies[journeyOrder[journeyIndex]];
                  // synth.triggerAttackRelease(allCubes[journeyOrder[journeyIndex]].userData.frequency, "8n");

                  // playNote(frequency);
                }



                  // Calculate interpolation factor
                  const lerpFactor = movementProgress / movementDuration;

                  // Move the camera to the current cube's position with an offset
                  const targetPosition = allCubes[journeyOrder[journeyIndex]].position.clone().add(new THREE.Vector3(0, 0, 5));
                  // TODO: come back and replays on your local machine
                  // socket.emit("cubeVisited", allCubes[journeyOrder[journeyIndex]].uuid);

                  camera.position.lerp(targetPosition, lerpFactor);
            }
            requestAnimationFrame(animate);
              const visitDuration = 3000; // Duration of each visit in milliseconds

            // moveCamera();
            // if (journeyIndex<journeyOrder.length-1)
            //   journeyIndex++;
            // else 
            //   journeyIndex= 0;
            renderer.render(scene, camera);
        };

        animate();
        
        // Tone.Transport.start();
        // sequence.start();
    };


window.playJourney = playJourney;


<!-- SECTION: hypercube -->

            // if(!hyperCubeRendered)
            // {
            //     hyperCubeRendered = true;

            // }



 let t = 0.0;

// let scene, camera, renderer;
let geometry, material;

let edges = [];
let vertexCoords = [];
let vertexCoords2 = [];
let vertexJoins = [];

var hyperCubeRendered=false; 

                init();
                render();


function path(p1, p2, p3, p4, i) {

  let vec = new THREE.Vector3(0,0,0);

  if (i >= 0 && i < 0.25) {
    vec.x = p4.x + (p1.x - p4.x ) * i * 4;
    vec.y = p4.y + (p1.y - p4.y ) * i * 4;
    vec.z = p4.z + (p1.z - p4.z ) * i * 4;
  } else if (i >= 0.25 && i < 0.5) {
    vec.x = p1.x + (p2.x - p1.x ) * (i - 0.25) * 4;
    vec.y = p1.y + (p2.y - p1.y ) * (i - 0.25) * 4;
    vec.z = p1.z + (p2.z - p1.z ) * (i - 0.25) * 4;
  } else if (i >= 0.5 && i < 0.75) {
    vec.x = p2.x + (p3.x - p2.x ) * (i - 0.5) * 4;
    vec.y = p2.y + (p3.y - p2.y ) * (i - 0.5) * 4;
    vec.z = p2.z + (p3.z - p2.z ) * (i - 0.5) * 4;
  } else if (i >= 0.75 && i < 1.0) {
    vec.x = p3.x + (p4.x - p3.x ) * (i - 0.75) * 4;
    vec.y = p3.y + (p4.y - p3.y ) * (i - 0.75) * 4;
    vec.z = p3.z + (p4.z - p3.z ) * (i - 0.75) * 4;
  }

  return vec;
}

function init() {

  vertexCoords[0]  = new THREE.Vector3(-5,-5,-5);
  vertexCoords[1]  = new THREE.Vector3( 5,-5,-5);
  vertexCoords[2]  = new THREE.Vector3( 5, 5,-5);
  vertexCoords[3]  = new THREE.Vector3(-5, 5,-5);
  vertexCoords[4]  = new THREE.Vector3(-5,-5, 5);
  vertexCoords[5]  = new THREE.Vector3( 5,-5, 5);
  vertexCoords[6]  = new THREE.Vector3( 5, 5, 5);
  vertexCoords[7]  = new THREE.Vector3(-5, 5, 5);
  vertexCoords[8]  = new THREE.Vector3(-10,-10,-10);
  vertexCoords[9]  = new THREE.Vector3( 10,-10,-10);
  vertexCoords[10] = new THREE.Vector3( 10, 10,-10);
  vertexCoords[11] = new THREE.Vector3(-10, 10,-10);
  vertexCoords[12] = new THREE.Vector3(-10,-10, 10);
  vertexCoords[13] = new THREE.Vector3( 10,-10, 10);
  vertexCoords[14] = new THREE.Vector3( 10, 10, 10);
  vertexCoords[15] = new THREE.Vector3(-10, 10, 10);

  vertexJoins = [
    [0,1], [1,2], [2,3], [3,0],
    [0,4], [1,5], [2,6], [3,7],
    [4,5], [5,6], [6,7], [7,4],

    [0,8], [1,9], [2,10], [3,11],
    [4,12], [5,13], [6,14], [7,15],

    [8,9], [9,10], [10,11], [11,8],
    [8,12], [9,13], [10,14], [11,15],
    [12,13], [13,14], [14,15], [15,12]
  ];

  // scene = new THREE.Scene();
  // camera = new THREE.OrthographicCamera( window.innerWidth / - 4, window.innerWidth / 4, window.innerHeight / 4, window.innerHeight / - 4, 1, 1000 );
  // camera.position.set(200,-100,-300);
  // camera.lookAt(new THREE.Vector3(0,0,0));

  // renderer = new THREE.WebGLRenderer();
  // renderer.setSize(window.innerWidth / 2, window.innerHeight / 2);
  document.getElementById('hypercube').appendChild(renderer.domElement);

  for (let i = 0; i < vertexJoins.length; i++) {

    geometry = new THREE.Geometry();
    geometry.vertices.push(vertexCoords[vertexJoins[i][0]]);
    geometry.vertices.push(vertexCoords[vertexJoins[i][1]]);
    let line = new THREE.Line(geometry, new THREE.LineBasicMaterial({
      color: 0x00ff00,
      linewidth: 4
    }));
    scene.add(line);
    edges[i] = line;

  }

}

function render() {
  t = (t + 0.002) % 1;

  vertexCoords2[0]  = path(vertexCoords[8], vertexCoords[9], vertexCoords[1], vertexCoords[0], t);
  vertexCoords2[1]  = path(vertexCoords[0], vertexCoords[8], vertexCoords[9], vertexCoords[1], t);
  vertexCoords2[9]  = path(vertexCoords[1], vertexCoords[0], vertexCoords[8], vertexCoords[9], t);
  vertexCoords2[8]  = path(vertexCoords[9], vertexCoords[1], vertexCoords[0], vertexCoords[8], t);

  vertexCoords2[3]  = path(vertexCoords[11], vertexCoords[10], vertexCoords[2], vertexCoords[3], t);
  vertexCoords2[2]  = path(vertexCoords[3], vertexCoords[11], vertexCoords[10], vertexCoords[2], t);
  vertexCoords2[10]  = path(vertexCoords[2], vertexCoords[3], vertexCoords[11], vertexCoords[10], t);
  vertexCoords2[11]  = path(vertexCoords[10], vertexCoords[2], vertexCoords[3], vertexCoords[11], t);

  vertexCoords2[4]  = path(vertexCoords[12], vertexCoords[13], vertexCoords[5], vertexCoords[4], t);
  vertexCoords2[5]  = path(vertexCoords[4], vertexCoords[12], vertexCoords[13], vertexCoords[5], t);
  vertexCoords2[13]  = path(vertexCoords[5], vertexCoords[4], vertexCoords[12], vertexCoords[13], t);
  vertexCoords2[12]  = path(vertexCoords[13], vertexCoords[5], vertexCoords[4], vertexCoords[12], t);

  vertexCoords2[7]  = path(vertexCoords[15], vertexCoords[14], vertexCoords[6], vertexCoords[7], t);
  vertexCoords2[6]  = path(vertexCoords[7], vertexCoords[15], vertexCoords[14], vertexCoords[6], t);
  vertexCoords2[14]  = path(vertexCoords[6], vertexCoords[7], vertexCoords[15], vertexCoords[14], t);
  vertexCoords2[15]  = path(vertexCoords[14], vertexCoords[6], vertexCoords[7], vertexCoords[15], t);

  requestAnimationFrame(render);

  for (let i = 0; i < edges.length; i++) {

    edges[i].geometry.vertices[0] = vertexCoords2[vertexJoins[i][0]];
    edges[i].geometry.vertices[1] = vertexCoords2[vertexJoins[i][1]];
    edges[i].rotation.x = 0;
    edges[i].rotation.y = 0;
    edges[i].rotation.z = 0;
    edges[i].geometry.verticesNeedUpdate = true;
  }

  renderer.render(scene, camera);
}


<!-- image processing -->

function deepClone(object) {
  const clonedObject = object.clone();
  if (object.children) {
    for (const child of object.children) {
      clonedObject.add(deepClone(child));
    }
  }
  if (object.material) {
    clonedObject.material = object.material.clone();
  }
  if (object.geometry) {
    clonedObject.geometry = object.geometry.clone();
  }
  return clonedObject;
}

//NOTE/TODO: This works but also doesn't work in that it doesn't reconstruct the child objects.
async function takeSnapshot(cube) {




  // Create a new scene for the snapshot
  const snapshotScene = new THREE.Scene();

  // Clone the cube to avoid affecting the original cube
  const clonedCube = deepClone(cube);
  snapshotScene.add(clonedCube);


  // Set the position of the cloned cube
  clonedCube.position.set(0, 0, 0);

  // Create a new camera for the snapshot
  const snapshotCamera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  snapshotCamera.position.z = 5;

  // Set the renderer size to the desired image size
  renderer.setSize(256, 256);

  // Render the snapshot scene with the snapshot camera
  renderer.render(snapshotScene, snapshotCamera);



  // Get the snapshot as a data URL
  const imageDataUrl = renderer.domElement.toDataURL('image/png');

  // Fetch the image data as a Blob
  const response = await fetch(imageDataUrl);
  const blob = await response.blob();

  // Save the snapshot as an image file using FileSaver
  saveAs(blob, 'snapshot.png');

   renderer.setSize(window.innerWidth, window.innerHeight);

}


<!---  SECTION: terminal -->


// Create a new terminal instance
const terminal = new Terminal();
var lastAction = "";
// Create and load the addons
const fitAddon = new FitAddon.FitAddon();
terminal.loadAddon(fitAddon);
const webglAddon = new WebglAddon.WebglAddon();
terminal.loadAddon(webglAddon);

// Attach the terminal to the DOM element
terminal.open(document.getElementById('terminal'));

// Fit the terminal to its container
fitAddon.fit();

// Set up a simple prompt
// terminal.write('Welcome to Jarca! Jarca is a fusion of GPT-Jargon and Arca. \r\n');

terminal.write('Commands: "library" "play" "stop" "faster" "slower" "claim" \r\n');
terminal.write('$ ');

// const player = new Tone.Player('chopin_nocturne_20.mp3').toDestination();
// await Tone.start();

// Handle user input
let inputBuffer = '';

terminal.onData((data) => {
  // If the user pressed Enter, process the command
  if (data === '\r') {
    const command = inputBuffer.trim();
    inputBuffer = '';
    // Process the command
    console.log("User typed command:", command);
    //C4 D4 E4 F4 G4 A4 B4 C5

    if (lastAction == "claimed"){
      socket.emit("claim", {"activeUser": activeUser, "cube": selectedCube, "name":command});
      allCubes[selectedCube].name = "command";
    }

    if(command == 'help') {
      terminal.write('  "library" "play" "stop" "faster" "slower" "claim" .\r\n');

  }
    if(command == 'library') {

      terminal.write(' Beethoven for op. 131 remix. Chopin for Nocturne 20 remix.\r\n');

    }
    if(command == 'claim') {

      if(activeUser == "")
        terminal.write('   You are not logged in. You cannot claim.\r\n');
      else  
      {
        socket.emit("claim", {"activeUser": activeUser, "cube": selectedCube});
        terminal.write('Cube ' + selectedCube + ' belongs to you. Please give it a name.\r\n');
        lastAction = "claimed";

      }


    }
    if(command.includes('Beethoven')) {
      const bplayer = new Tone.Player("beethoven_op131_allegro_001.mp3").toDestination();
      bplayer.autostart = true;
      playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 120, 2, 3, 4, 70]);
          // playMelody();
    } else if(command.includes('Chopin')) {
        const cplayer = new Tone.Player("beethoven_op131_allegro_001.mp3").toDestination();
          playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 120, 2, 3, 4, 70]);
          // playMelody();
          cplayer.autostart = true;
    } else if (command == 'play melody') {
      playMelody(); 

    } if(command.startsWith('play') && command.length > 5)
    {

      const melody = command.substring(5,command.length);

      const inputArray = melody.split(' ');
      const outputArray = inputArray.map((note) => {
        return { note: note, duration: "4n" };
      });

      // var playableMelody = [];
      playMelody(outputArray);

      
      // melody.split(' ').forEach({
      //     //TODO: BUG in this line
      //     // playableMelody.add({note: self, duration: '4n'});
        
      // }
    }

    if(command == 'mine') {


          terminal.write('you don\'t have enough monet to mine.\r\n');

          // playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70]);

         }

     if(command == 'stop') {
          player.stop();
          playJourney([]);

         }
         if(command == 'faster') {
          bpm += 10;
          console.log(bpm);

          // playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70]);

         }
         if(command == 'slower') {
          bpm -= faster;
          console.log(bpm);
          // playJourney([0, 2, 1, 3, 6, 55, 4, 3, 100, 2, 3, 300, 2, 3, 4, 70]);

         }

    // Clear the line and print a new prompt
    terminal.write('\x1B[2K\x1B[G');
    terminal.write('$ ');

  // If the user pressed Backspace, remove the last character from the input buffer
  } else if (data === '\x7F') {
    inputBuffer = inputBuffer.slice(0, -1);
    terminal.write('\b \b');

  // Otherwise, add the character to the input buffer and display it in the terminal
  } else {
    inputBuffer += data;
    terminal.write(data);
  }
});


function noteToMidi(note) {
  console.log(note);
  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const octave = parseInt(note.slice(-1));
  const noteName = note.slice(0, -1);
  const noteIndex = noteNames.indexOf(noteName);

  return noteIndex + 12 * (octave + 1);
}



function playMelody(melody) {

    console.log(melody);
    

    if(melody==null || melody.length < 2)
          melody = [
            { note: 'E4', duration: '4n' },
            { note: 'B4', duration: '4n' },
            { note: 'D5', duration: '4n' },
            { note: 'C5', duration: '4n' },
            { note: 'B4', duration: '4n' },
            { note: 'A4', duration: '4n' },
            { note: 'G4', duration: '4n' },
            { note: 'F#4', duration: '4n' },
          ];

    const synth = new Tone.PolySynth(Tone.Synth).toDestination();

    // Define the notes and durations for the first few measures of Chopin's Prelude in E minor

    const bass = [
      { note: 'E2', duration: '1m' },
      { note: 'G2', duration: '1m' },
    ];

    journeyOrder = [];

    // Schedule the notes to be played
    let time = 0;
    melody.forEach(({ note, duration }) => {
      // console.log(self);
      // if(self instanceof String) {
        
      //   note = self;
      //   duration = '4n';
      // }

      // if (!duration || duration.length < 2)
      //   duration = '4n';

      journeyOrder.push(noteToMidi(note));
      synth.triggerAttackRelease(note, duration, time);
      time += Tone.Time(duration).toSeconds();
    });

   console.log(journeyOrder);    

    bass.forEach(({ note, duration }, index) => {
      synth.triggerAttackRelease(note, duration, Tone.Time(duration).toSeconds() * index);
    });

    // Start playing the music
    Tone.Transport.start();
    playJourney(journeyOrder);


}
<!-- SECTION: CREDITS --> 




// async function getUserBalance(activeUser, (err, balance) => {
//   if (err) {
//     console.error('Error fetching balance:', err);
//   } else if (balance !== null) {
//     console.log('Balance fetched:', balance);
//   } else {
//     console.log('User not found.');
//   }
// });



// getUserBalance(userId) {
//   const response = await fetch(`/api/users/${userId}/balance`);
//   const data = await response.json();

//   return data.balance;
// }

function updateBalanceDisplay(balance) {
  const balanceElement = document.getElementById("balance");
  balanceElement.textContent = `Credits: ${balance}`;
}

async function onUserLogin(userId) {
  const balance = await getUserBalance(userId);
  updateBalanceDisplay(balance);
}



    </script>




</body>
</html>
